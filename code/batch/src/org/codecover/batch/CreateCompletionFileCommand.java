/******************************************************************************
 * Copyright (c) 2007 Stefan Franke, Robert Hanussek, Benjamin Keil,          *
 *                    Steffen Kieß, Johannes Langauf,                         *
 *                    Christoph Marian Müller, Igor Podolskiy,                *
 *                    Tilmann Scheller, Michael Starzmann, Markus Wittlinger  *
 * All rights reserved. This file may be used, modifies and redistributed     *
 * under the terms of either the Eclipse Public License v1.0 which            *
 * accompanies this distribution and is available at                          *
 * http://www.eclipse.org/legal/epl-v10.html or the MIT license, available at *
 * http://www.opensource.org/licenses/mit-license.php                         *
 ******************************************************************************/

package org.codecover.batch;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.codecover.batch.HelpCommand.CommandCollectionProvider;

/**
 * CreateCompletionFileCommand
 * 
 * @author Steffen Kieß
 * @version 1.0 ($Id: CreateCompletionFileCommand.java 1 2007-12-12 17:37:26Z t-scheller $)
 */
public class CreateCompletionFileCommand extends Command {
    private final CommandCollectionProvider commandCollectionProvider;
    
    /**
     * Creates a CreateCompletionFileCommand
     * 
     * @param commandCollectionProvider
     *            the provider carrying the list of commands
     */
    public CreateCompletionFileCommand(CommandCollectionProvider commandCollectionProvider) {
        super(null,
              "create-bash-completion-file",
              "create a completion file for bash and print it to stdout or the given file",
              OptionSet.EMPTY,
              0, 1, true);

        if (commandCollectionProvider == null) {
            throw new NullPointerException("commandCollectionProvider == null");
        }

        this.commandCollectionProvider = commandCollectionProvider;
    }
    
    private static String bashEscape(String s) {
        return "'" + s.replace("'", "'\\''") + "'";
    }

    private static String bashEscape(List<String> list) {
        final StringBuilder sb = new StringBuilder();
        boolean first = true;
        
        for (String s : list) {
            if (!first) {
                sb.append(" ");
            }
            first = false;
            sb.append(s);
        }
        
        return bashEscape(sb.toString());
    }
    
    private static final String functionName = "_codecover_completion";
    
    private static List<String> getOpts(Option option) {
        final List<String> list = new ArrayList<String>();
        if (option.getShortOption() != '\0') {
            list.add("-" + option.getShortOption());
        }
        if (option.getLongOption() != null) {
            list.add("--" + option.getLongOption());
        }
        return Collections.unmodifiableList(list);
    }

    private static List<String> getOpts(Set<Option> options) {
        final List<String> list = new ArrayList<String>();
        
        for (final Option option : options) {
            list.addAll(getOpts(option));
        }
        
        return Collections.unmodifiableList(list);
    }
    
    private static Set<Option> filterWithArgument(Set<Option> options) {
        final Set<Option> list = new HashSet<Option>();
        
        for (final Option option : options) {
            if (option.getHasArgument()) {
                list.add(option);
            }
        }
        
        return Collections.unmodifiableSet(list);
    }
    
    private static String getOrList(String expr, List<String> list) {
        final StringBuilder sb = new StringBuilder();
        
        if (list.isEmpty()) {
            return "[ 1 = 0 ]";
        }
        
        boolean first = true;
        
        for (final String s : list) {
            if (!first) {
                sb.append("-o ");
            }
            first = false;
            sb.append(expr);
            sb.append(" = ");
            sb.append(bashEscape(s));
            sb.append(" ");
        }
        
        return "[ " + sb.toString() + "]";
    }
    
    //TODO: Stuff like -qp (should hide -q, -v, ...)
    
    // The completion script is heavily based on the svn script
    private static void writeCompletionFile(StringBuilder sb, CommandCollection commands) {
        sb.append("# This file is autogenerated. DO NOT EDIT.\n");
        sb.append("# Generated by 'codecover create-bash-completion-file'\n");
        sb.append("# $Id: CreateCompletionFileCommand.java 1 2007-12-12 17:37:26Z t-scheller $\n");
        sb.append("\n");
        sb.append("shopt -s extglob\n");
        sb.append("\n");
        sb.append(functionName + "() {\n");
        sb.append("\tlocal cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt\n");
        sb.append("\t\n");
        sb.append("\tCOMPREPLY=()\n");
        sb.append("\tcur=${COMP_WORDS[COMP_CWORD]}\n");
        sb.append("\t\n");

        sb.append("\t# Possible expansions, without pure-prefix abbreviations and without hidden commands\n");
        final List<String> cmdList = new ArrayList<String>();
        for (final Command command : commands.getSortedCommands()) {
            if (!command.isHidden()) {
                cmdList.addAll(command.getAllAliases());
            }
        }
        sb.append("\tcmds=" + bashEscape(cmdList) + "\n");
        sb.append("\t\n");

        sb.append("\t# help options have a strange command status...\n");
        sb.append("\tlocal helpOpts=" + bashEscape(getOpts(Options.help)) + "\n");
        sb.append("\t# all special options that have a command status\n");
        sb.append("\tlocal specOpts=" + bashEscape(getOpts(Options.version)) + "\" $helpOpts\"\n");
        sb.append("\t\n");
        sb.append("\tlocal cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0\n");
        sb.append("\tlocal prev= help= prop= val= isRevProp= last='none' nargs=0 stat=\n");
        sb.append("\tlocal options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=\n");
        sb.append("\t\n");
        sb.append("\tfor opt in \"${COMP_WORDS[@]}\"\n");
        sb.append("\tdo\n");
        sb.append("\t\t# get status of current word (from previous iteration)\n");
        sb.append("\t\t[[ $isCur ]] && stat=$last\n");
        sb.append("\t\t\n");
        sb.append("\t\t# are we processing the current word\n");
        sb.append("\t\tisCur=\n");
        sb.append("\t\t[[ $i -eq $COMP_CWORD ]] && isCur=1\n");
        sb.append("\t\tlet i++\n");
        sb.append("\t\t\n");
        sb.append("\t\t# FIRST must be the executable\n");
        sb.append("\t\t[ $last = 'none' ] && { last='first'; continue ; }\n");
        sb.append("\t\t\n");

        sb.append("\t\t# SKIP option arguments\n");
        sb.append("\t\tif " + getOrList("\"$prev\"", getOpts(filterWithArgument(commands.getMergedOptions().getAllOptions()))) + "; then\n");
        sb.append("\t\t\tprev=''\n");
        sb.append("\t\t\tlast='skip'\n");
        sb.append("\t\t\tcontinue;\n");
        sb.append("\t\tfi\n");
        sb.append("\t\t\n");
        sb.append("\t\t# Argh...  This looks like a bashbug...\n");
        sb.append("\t\t# Redirections are passed to the completion function\n");
        sb.append("\t\t# although it is managed by the shell directly...\n");
        sb.append("\t\t# It matters because we want to tell the user when no more\n");
        sb.append("\t\t# completion is available, so it does not necessary\n");
        sb.append("\t\t# fallback to the default case.\n");
        sb.append("\t\tif [[ $prev == @(<|>|>>|[12]>|[12]>>) ]] ; then\n");
        sb.append("\t\t\tprev=''\n");
        sb.append("\t\t\tlast='skip'\n");
        sb.append("\t\t\tcontinue ;\n");
        sb.append("\t\tfi\n");
        sb.append("\t\tprev=$opt\n");
        sb.append("\t\t\n");
        sb.append("\t\t# get the subCoMmanD\n");
        sb.append("\t\tif [[ ! $cmd && $opt \\\n");
        sb.append("\t\t\t&& ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]\n");
        sb.append("\t\tthen\n");
        sb.append("\t\t\tcmd=$opt\n");
        sb.append("\t\t\t[[ $cmd == @($propCmds) ]] && isPropCmd=1\n");
        sb.append("\t\t\t[[ $cmd == @($psCmds) ]] && isPsCmd=1\n");
        sb.append("\t\t\t[[ $cmd == @(${helpOpts// /|}) ]] && cmd='help'\n");
        sb.append("\t\t\t[[ $cmd = 'help' ]] && isHelpCmd=1\n");
        sb.append("\t\t\t# HELP about a command asked with an option\n");
        sb.append("\t\t\tif [[ $isHelpCmd && $cmd && $cmd != 'help' && ! $help ]]\n");
        sb.append("\t\t\tthen\n");
        sb.append("\t\t\t\thelp=$cmd\n");
        sb.append("\t\t\t\tcmd='help'\n");
        sb.append("\t\t\tfi\n");
        sb.append("\t\t\tlast='cmd'\n");
        sb.append("\t\t\tcontinue\n");
        sb.append("\t\tfi\n");
        sb.append("\t\t\n");
        sb.append("\t\t# HELP about a command\n");
        sb.append("\t\tif [[ $isHelpCmd && ! $help && $opt && $opt != -* ]]\n");
        sb.append("\t\tthen\n");
        sb.append("\t\t\thelp=$opt\n");
        sb.append("\t\t\tlast='help'\n");
        sb.append("\t\t\tcontinue\n");
        sb.append("\t\tfi\n");
        sb.append("\t\t\n");
        sb.append("\t\tif [[ $last != 'onlyarg' ]]\n");
        sb.append("\t\tthen\n");
        sb.append("\t\t\t# more OPTions\n");
        sb.append("\t\t\tif " + getOrList("\"$opt\"", getOpts(Options.help)) + "; then\n");
        sb.append("\t\t\t\tisHelpCmd=1\n");
        sb.append("\t\t\tfi\n");
        sb.append("\t\t\t\n");
        sb.append("\t\t\t# no more options, only arguments, whatever they look like.\n");
        sb.append("\t\t\tif [[ $opt = '--' && ! $isCur ]] ; then\n");
        sb.append("\t\t\t\tlast='onlyarg'\n");
        sb.append("\t\t\t\tcontinue\n");
        sb.append("\t\t\tfi\n");
        sb.append("\t\t\t\n");
        sb.append("\t\t\t# options are recorded...\n");
        sb.append("\t\t\tif [[ $opt == -* ]] ; then\n");
        sb.append("\t\t\t\t# but not the current one!\n");
        sb.append("\t\t\t\t[[ ! $isCur ]] && options=\"$options $opt \"\n");
        sb.append("\t\t\t\tlast='opt'\n");
        sb.append("\t\t\t\tcontinue\n");
        sb.append("\t\t\tfi\n");
        sb.append("\t\telse\n");
        sb.append("\t\t\t# onlyarg\n");
        sb.append("\t\t\tlet nargs++\n");
        sb.append("\t\t\tcontinue\n");
        sb.append("\t\tfi\n");
        sb.append("\t\t\t\n");
        sb.append("\t\t# then we have an argument\n");
        sb.append("\t\tlast='arg'\n");
        sb.append("\t\tlet nargs++\n");
        sb.append("\tdone\n");
        sb.append("\t[[ $stat ]] || stat=$last\n");
        sb.append("\t\t\t\n");
        sb.append("\t# suggest all subcommands, including special help\n");
        sb.append("\tif [[ ! $cmd || $stat = 'cmd' ]]\n");
        sb.append("\tthen\n");
        sb.append("\tCOMPREPLY=( $( compgen -W \"$cmds $specOpts\" -- $cur ) )\n");
        sb.append("\treturn 0\n");
        sb.append("\tfi\n");
        sb.append("\t\t\t\n");
        sb.append("\t# suggest all subcommands\n");
        sb.append("\tif [[ $stat = 'help' || ( $isHelpCmd && ! $help ) ]]\n");
        sb.append("\tthen\n");
        sb.append("\t\tCOMPREPLY=( $( compgen -W \"$cmds\" -- $cur ) )\n");
        sb.append("\t\treturn 0\n");
        sb.append("\tfi\n");
        sb.append("\t\t\t\n");
        sb.append("\t# help about option arguments\n");
        sb.append("\tif [[ $stat = 'skip' ]]\n");
        sb.append("\tthen\n");
        sb.append("\t\tlocal previous=${COMP_WORDS[COMP_CWORD-1]}\n");
        sb.append("\t\tlocal values= dirs= beep=\n");
        sb.append("\t\t\n");
        // That creates a lot of code which could be shorter.
        // Could be reimplemented a bit nicer
        for (final Command command : commands.getSortedCommands()) {
            boolean printedCommandIf = false;
            for (final Option option : filterWithArgument(command.getOptions().getAllOptions())) {
                if (!printedCommandIf) {
                    sb.append("\t\tif " + getOrList("\"$cmd\"", command.getAllAliases()) + "; then\n");
                    printedCommandIf = true;
                }
                sb.append("\t\t\tif " + getOrList("\"$previous\"", getOpts(option)) + "; then\n");
                final ArgumentType argumentType = option.getArgumentType();
                if (argumentType instanceof ArgumentType.Directory) {
                    sb.append("\t\t\t\tdirs=1\n");
                } else if (argumentType instanceof ArgumentType.Path) {
                    sb.append("\t\t\t\t:\n");
                } else if (argumentType instanceof ArgumentType.Number) {
                    sb.append("\t\t\t\tvalues='0 1 2 3 4 5 6 7 8 9'\n");
                } else if (argumentType instanceof ArgumentType.SuggestionList) {
                    sb.append("\t\t\t\tvalues=" + bashEscape(((ArgumentType.SuggestionList)argumentType).getSuggestions()) + "\n");
                } else if (argumentType instanceof ArgumentType.Opaque) {
                    sb.append("\t\t\t\tbeep=1\n");
                } else {
                    throw new RuntimeException("Unknown ArgumentType: " + argumentType.getClass());
                }
                sb.append("\t\t\tfi\n");
            }
            if (printedCommandIf) {
                sb.append("\t\tfi\n");
            }
        }
        sb.append("\t\t\n");
        sb.append("\t\t# if the previous option required a parameter, do something\n");
        sb.append("\t\t# or fallback on ordinary filename expansion\n");
        sb.append("\t\t[[ $values ]] && COMPREPLY=( $( compgen -W \"$values\" -- $cur ) )\n");
        sb.append("\t\t[[ $dirs ]] && COMPREPLY=( $( compgen -o dirnames -- $cur ) )\n");
        sb.append("\t\t[[ $beep ]] &&\n");
        sb.append("\t\t{\n");
        sb.append("\t\t\t# 'no known completion'. hummm.\n");
        sb.append("\t\t\techo -en \"\\a\"\n");
        sb.append("\t\t\tCOMPREPLY=( '' )\n");
        sb.append("\t\t}\n");
        sb.append("\t\treturn 0\n");
        sb.append("\tfi\n");
        sb.append("\n");
        sb.append("\t# maximum number of additional arguments expected in various forms\n");
        //TODO: command arguments (check number, type)
        sb.append("\tcase $cmd in\n");
        sb.append("\t\t*)\n");
        sb.append("\t\t\tnExpectArgs=0\n");
        sb.append("\t\t\t;;\n");
        sb.append("\t\thelp|h)\n");
        sb.append("\t\t\tnExpectArgs=0\n");
        sb.append("\t\t\t;;\n");
        sb.append("\t\t--version)\n");
        sb.append("\t\t\tnExpectArgs=0\n");
        sb.append("\t\t\t;;\n");
        sb.append("\tesac\n");
        sb.append("\n");
        /*
        sb.append("\t# the maximum number of arguments is reached for a command\n");
        sb.append("\tif [[ $nExpectArgs && $nargs -gt $nExpectArgs ]]\n");
        sb.append("\tthen\n");
        sb.append("\t\t# some way to tell 'no completion at all'... is there a better one?\n");
        sb.append("\t\t# Do not say 'file completion' here.\n");
        sb.append("\t\techo -en \"\\a\"\n");
        sb.append("\t\tCOMPREPLY=( '' )\n");
        sb.append("\t\treturn 0\n");
        sb.append("\tfi\n");
        sb.append("\\tn");
        */
        sb.append("\t# if not typing an option,\n");
        sb.append("\t# then fallback on ordinary filename expansion\n");
        sb.append("\t#if [[ $cur != -* || $stat = 'onlyarg' ]]  ; then\n");
        sb.append("\tif [[ $stat = 'onlyarg' ]]  ; then\n");
        sb.append("\t\treturn 0\n");
        sb.append("\tfi\n");
        sb.append("\t\n");
        
        sb.append("\tcmdOpts=\n");
        sb.append("\t\n");
        for (final Command command : commands.getSortedCommands()) {
            sb.append("\tif " + getOrList("\"$cmd\"", command.getAllAliases()) + "; then\n");
            sb.append("\t\tcmdOpts=' '" + bashEscape(getOpts(command.getOptions().getAllOptions())) + "' '\n");
            sb.append("\t\t\n");
            sb.append("\t\t# take out options already given\n");
            sb.append("\t\tfor opt in $options\n");
            sb.append("\t\tdo\n");
            sb.append("\t\t\t\n");
            for (final Option option : command.getOptions().getAllOptions()) {
                boolean printedIf = false;
                for (final Option otherOption : command.getOptions().getAllOptions()) {
                    if ((option == otherOption && !option.getCanAppearMultipleTimes()) || option.excludes(otherOption)) {
                        if (!printedIf) {
                            sb.append("\t\t\tif " + getOrList("\"$opt\"", getOpts(option)) + "; then\n");
                            printedIf = true;
                        }
                        for (final String s : getOpts(otherOption)) {
                            sb.append("\t\t\t\tcmdOpts=${cmdOpts/ " + bashEscape(s) + " / }\n");
                        }
                    }
                }
                if (printedIf) {
                    sb.append("\t\t\tfi\n");
                }
                sb.append("\t\t\t\n");
            }
            sb.append("\t\t\t\n");
            sb.append("\t\t\t# remove help options within help subcommand\n");
            sb.append("\t\t\tif [ $isHelpCmd ] ; then\n");
            for (final String s : getOpts(Options.help)) {
                sb.append("\t\t\t\tcmdOpts=${cmdOpts/ " + bashEscape(s) + " / }\n");
            }
            sb.append("\t\t\tfi\n");
            sb.append("\t\tdone\n");
            sb.append("\tfi\n");
            sb.append("\t\n");
        }
        sb.append("\t\n");
        sb.append("\t\n");
        sb.append("\t# provide help about available options\n");
        sb.append("\tCOMPREPLY=( $( compgen -W \"$cmdOpts\" -- $cur ) )\n");
        sb.append("\treturn 0\n");
        sb.append("}\n");
        sb.append("\n");
        sb.append("complete -F " + functionName + " -o default codecover\n");
        sb.append("complete -F " + functionName + " -o default codecover.sh\n");
    }
    
    @Override
    protected int run(CommandLine cl, BatchLogger logger, org.codecover.model.extensions.PluginManager pluginManager) {
        CommandCollection commands = this.commandCollectionProvider.get();
        if (commands == null) {
            throw new NullPointerException();
        }
        
        final StringBuilder sb = new StringBuilder();

        writeCompletionFile(sb, commands);
        
        if (cl.getNonOptionArgs().size() > 0) {
            final String filename = cl.getNonOptionArgs().get(0);
            final PrintStream printStream;
            try {
                printStream = new PrintStream(filename, "utf-8");
            } catch (FileNotFoundException e) {
                logger.fatal(e.getMessage(), e);
                throw new RuntimeException();
            } catch (UnsupportedEncodingException e) {
                // utf-8 should always be there
                throw new RuntimeException(e);
            }
            printStream.print(sb.toString());
            printStream.close();
        } else {
            System.out.print(sb.toString());
        }
        
        return 0;
    }

}
