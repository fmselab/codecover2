/******************************************************************************
 * Copyright (c) 2007 Stefan Franke, Robert Hanussek, Benjamin Keil,          *
 *                    Steffen Kieß, Johannes Langauf,                         *
 *                    Christoph Marian Müller, Igor Podolskiy,                *
 *                    Tilmann Scheller, Michael Starzmann, Markus Wittlinger  *
 * All rights reserved. This program and the accompanying materials           *
 * are made available under the terms of the Eclipse Public License v1.0      *
 * which accompanies this distribution, and is available at                   *
 * http://www.eclipse.org/legal/epl-v10.html                                  *
 ******************************************************************************/

//
// Generated by JTB 1.3.2
package org.codecover.instrumentation.cobol85.visitor;

import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;

import org.codecover.instrumentation.cobol85.compilerDirectives.CompilerDirectives;
import org.codecover.instrumentation.cobol85.compilerDirectives.CompilerDirectivesManipulator;
import org.codecover.instrumentation.cobol85.syntaxtree.NodeToken;

/**
 * Dumps the syntax tree to a Writer using the location information in each
 * NodeToken.
 * 
 * @author Stefan Franke
 * @version 1.0 ($Id: TreeDumper.java 1 2007-12-12 17:37:26Z t-scheller $)
 * 
 */
@SuppressWarnings("all")
public class TreeDumper extends DepthFirstVisitor {
    private CompilerDirectives compilerDirectives;

    /**
     * An unmodified output writer for writing of the tokens. 
     */
    private PrintWriter printWriter;

    private int position = 0;

    /**
     * Constructs a new {@link TreeDumper}.
     *
     * @param o the output writer
     * @param compilerDirectives the compiler directives
     */
    public TreeDumper(Writer o, CompilerDirectives compilerDirectives) {
        this.printWriter = new PrintWriter(o, true);
        this.compilerDirectives = compilerDirectives;
    }

    /**
     * Flushes the OutputStream or Writer that this TreeDumper is using.
     */
    public void flushWriter() {
        this.printWriter.flush();
    }

    /**
     * Returns the modified output writer for instrumentation purposes.
     * 
     * @return the output writer
     */
    protected PrintWriter getOut() {
        return this.printWriter;
    }

    /**
     * @return the position of the writing cursor
     */
    public int getPosition() {
        return position;
    }

    /**
     * Visits special tokens of a node token.
     * 
     * @param n
     *                node token
     */
    protected void printSpecials(NodeToken n) {
        if (n.numSpecials() > 0) {
            for (NodeToken nt : n.specialTokens) {
                visit(nt);
            }
        }
    }

    /**
     * Prints the token's image to the unmodified output writer.
     */
    private void printToken(String s) {
        this.printWriter.print(s);
    }

    /**
     * Dumps the current NodeToken to the output stream being used.
     * 
     * The used grammar contains all the white spaces in tokens. Therefore, we
     * don't need to reconstruct the column and line positions.<br>
     * &rarr; removed exception<br>
     * &rarr; removed additional whitespace productions
     */
    public void visit(NodeToken n) {
        if (n.beginLine == -1 || n.beginColumn == -1) {
            printToken(n.tokenImage);
            return;
        }

        printSpecials(n);

        if (!this.compilerDirectives.isEmpty()) {
            int charPosition = this.compilerDirectives
                    .getCompilerDirectivePosition();
            while (charPosition <= n.endOffset && charPosition >= n.startOffset) {
                charPosition = charPosition - n.startOffset - 1;
                char[] chars = n.tokenImage.toCharArray();
                chars[charPosition] = this.compilerDirectives
                        .getCompilerDirective();
                n.tokenImage = String.copyValueOf(chars);
                this.compilerDirectives.goToNextCompilerDirective();
                if (!this.compilerDirectives.isEmpty()) {
                    charPosition = this.compilerDirectives
                            .getCompilerDirectivePosition();
                } else {
                    charPosition = -1;
                }
            }
        }
        printToken(n.tokenImage);
        this.position = n.endOffset;
    }

}
