/******************************************************************************
 * Copyright (c) 2007 Stefan Franke, Robert Hanussek, Benjamin Keil,          *
 *                    Steffen Kieß, Johannes Langauf,                         *
 *                    Christoph Marian Müller, Igor Podolskiy,                *
 *                    Tilmann Scheller, Michael Starzmann, Markus Wittlinger  *
 * All rights reserved. This program and the accompanying materials           *
 * are made available under the terms of the Eclipse Public License v1.0      *
 * which accompanies this distribution, and is available at                   *
 * http://www.eclipse.org/legal/epl-v10.html                                  *
 ******************************************************************************/

// Generated by JTB 1.3.2
package org.codecover.instrumentation.cobol85.visitor;

import java.io.StringWriter;

import org.codecover.instrumentation.cobol85.syntaxtree.NodeToken;

/**
 * Dumps the syntax tree to a Writer using the location information in each
 * NodeToken.
 */
@SuppressWarnings("all")
public class TreeStringDumper extends DepthFirstVisitor {
    private StringWriter writer = new StringWriter();

    private int position = 0;

    /**
     * The default constructor uses System.out as its output location. You may
     * specify your own Writer or OutputStream using one of the other
     * constructors.
     */
    public TreeStringDumper() {
        reset();
    }

    public void reset() {
        this.writer = new StringWriter();
    }

    public String getContent() {
        return this.writer.toString().trim();
    }

    /**
     * Dumps the current NodeToken to the output stream being used.
     * 
     * @throws IllegalStateException
     *             if the token position is invalid relative to the current
     *             position, i.e. its location places it before the previous
     *             token.
     */
    @Override
    public void visit(NodeToken n) {
        if (n.beginLine == -1 || n.beginColumn == -1) {
            printToken(n.tokenImage);
            return;
        }

        //
        // Handle special tokens
        //
        if (n.numSpecials() > 0) {
            for (NodeToken nt : n.specialTokens) {
                visit(nt);
            }
        }

        this.position = n.endOffset;
        printToken(n.tokenImage);
    }

    private void printToken(String s) {
        this.writer.write(s);
    }

    /**
     * @return the position of the writing cursor
     */
    public int getPosition() {
        return position;
    }
}
