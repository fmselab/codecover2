/******************************************************************************
 * Copyright (c) 2007 Stefan Franke, Robert Hanussek, Benjamin Keil,          *
 *                    Steffen Kieß, Johannes Langauf,                         *
 *                    Christoph Marian Müller, Igor Podolskiy,                *
 *                    Tilmann Scheller, Michael Starzmann, Markus Wittlinger  *
 * All rights reserved. This program and the accompanying materials           *
 * are made available under the terms of the Eclipse Public License v1.0      *
 * which accompanies this distribution, and is available at                   *
 * http://www.eclipse.org/legal/epl-v10.html                                  *
 ******************************************************************************/

package org.codecover.instrumentation.java15.syntaxtree;

import java.io.IOException;
import java.io.NotSerializableException;
import java.util.Vector;

import org.codecover.instrumentation.java15.parser.JavaParserConstants;
import org.codecover.instrumentation.java15.parser.Token;
import org.codecover.instrumentation.java15.visitor.GJNoArguVisitor;
import org.codecover.instrumentation.java15.visitor.GJVisitor;
import org.codecover.instrumentation.java15.visitor.GJVoidVisitor;
import org.codecover.instrumentation.java15.visitor.TreeSourceFileImageDumper;
import org.codecover.instrumentation.java15.visitor.Visitor;
import org.codecover.instrumentation.java15.visitor.VisitorWithException;
import org.codecover.model.mast.SourceFile;

/**
 * Represents a single token in the grammar. If the "-tk" option is used, also
 * contains a Vector of preceding special tokens.
 * 
 * @author Generated by JTB 1.3.2
 * @author Christoph Müller: divide into parsed and sourceFileImage &rarr; a
 *         normal {@link NodeToken} has only one reference to the image, because 
 *         its sourceFileImage and parsedImage are the same.<br>
 *         The EscapedNodeToken stores two different images.<br>
 *         {@link #createToken(Token)} creates a {@link NodeToken} of the correct
 *         type out of a {@link Token};
 */
@SuppressWarnings("all")
public class NodeToken implements Node {
    private Node parent;

    public Vector<NodeToken> specialTokens;

    public int startLine;
    
    public int startOffset;

    public int endOffset;

    public int kind;

    private String sourceFileParsedImage;

    NodeToken(String image) {
        throw new UnsupportedOperationException("use NodeToken.create()");
    }
    
    NodeToken(String sourceFileParsedImage,
              int kind,
              int startLine,
              int startOffset,
              int endOffset) {
        this.sourceFileParsedImage = sourceFileParsedImage;
        this.kind = kind;
        this.startLine = startLine;
        this.startOffset = startOffset;
        this.endOffset = endOffset;
        this.specialTokens = null;
    }

    public String getSourceFileImage() {
        return this.sourceFileParsedImage;
    }

    public String getParsedImage() {
        return this.sourceFileParsedImage;
    }

    public NodeToken getSpecialAt(int i) {
        if (specialTokens == null)
            throw new java.util.NoSuchElementException("No specials in token");
        return specialTokens.elementAt(i);
    }

    public int numSpecials() {
        if (specialTokens == null)
            return 0;
        return specialTokens.size();
    }

    public void addSpecial(NodeToken s) {
        if (specialTokens == null)
            specialTokens = new Vector<NodeToken>();
        specialTokens.addElement(s);
        s.setParent(this);
    }

    public void trimSpecials() {
        if (specialTokens == null)
            return;
        specialTokens.trimToSize();
    }

    public void setParent(Node n) {
        parent = n;
    }

    public Node getParent() {
        return parent;
    }

    @Override
    public String toString() {
        return getParsedImage();
    }

    public void accept(VisitorWithException v) throws IOException {
        v.visit(this);
    }

    public void accept(Visitor v) {
        v.visit(this);
    }

    public <R, A> R accept(GJVisitor<R, A> v, A argu) {
        return v.visit(this, argu);
    }

    public <R> R accept(GJNoArguVisitor<R> v) {
        return v.visit(this);
    }

    public <A> void accept(GJVoidVisitor<A> v, A argu) {
        v.visit(this, argu);
    }

    static class EscapedNodeToken extends NodeToken {
        private String sourceFileImage;

        public EscapedNodeToken(String sourceFileImage, String parsedImage,
                int kind, int startLine, int startOffset, int endOffset) {
            super(parsedImage, kind, startLine, startOffset, endOffset);

            this.sourceFileImage = sourceFileImage;
        }

        @Override
        public String getSourceFileImage() {
            return this.sourceFileImage;
        }
    }

    public static NodeToken createToken(Token t) {
        // we can use ==, because we used .intern() before
        if (t.getSourceFileImage() == t.getParsedImage()) {
            return new NodeToken(t.getSourceFileImage(), t.kind, t.beginLine,
                    t.startOffset, t.endOffset);
        }

        return new EscapedNodeToken(t.getSourceFileImage(), t.getParsedImage(),
                t.kind, t.beginLine, t.startOffset, t.endOffset);
    }
}
