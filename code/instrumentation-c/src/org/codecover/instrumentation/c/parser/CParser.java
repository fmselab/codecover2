/* Generated By:JavaCC: Do not edit this line. CParser.java */
package org.codecover.instrumentation.c.parser;

import java.util.*;
import org.codecover.instrumentation.c.syntaxtree.*;
import java.util.Vector;


public class CParser implements CParserConstants {
   private ArrayList<HashMap<String, Boolean>> types = new ArrayList<HashMap<String, Boolean>>();
   {
      startScope();
   }
   String lastType;
   private Stack<Boolean> typedefParsingStack = new Stack<Boolean>();
   private boolean isType(String type)
   {
      for ( int i = types.size() - 1; i >= 0; i-- )
      {
         Boolean ret = types.get(i).get(type);
         if ( ret != null )
            return ret;
      }
      return false;
   }
   public void addDecl(String name,boolean isType)
   {
      types.get(types.size() - 1).put(name,isType);
   }
   public void startScope()
   {
      types.add(new HashMap<String, Boolean>());
   }
   public void endScope()
   {
      types.remove(types.size() - 1);
   }

  final public Constant Constant() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch (jj_nt.kind) {
    case NUMBER:
      n2 = jj_consume_token(NUMBER);
                    n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case CHARACTER_LITERAL:
      n4 = jj_consume_token(CHARACTER_LITERAL);
                               n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Constant(n0);}
    throw new Error("Missing return statement in function");
  }

  final public EnumerationConstant EnumerationConstant() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new EnumerationConstant(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StringLiteral StringLiteral() throws ParseException {
   NodeList n0 = new NodeList();
   NodeToken n1;
   Token n2;
    label_1:
    while (true) {
      n2 = jj_consume_token(STRING_LITERAL);
                            n1 = JTBToolkit.makeNodeToken(n2);
        n0.addNode(n1);
      switch (jj_nt.kind) {
      case STRING_LITERAL:
        ;
        break;
      default:
        break label_1;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new StringLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PrimaryExpression PrimaryExpression() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   Constant n3;
   StringLiteral n4;
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   Expression n8;
   NodeToken n9;
   Token n10;
   GenericSelection n11;
    switch (jj_nt.kind) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
                        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case NUMBER:
    case CHARACTER_LITERAL:
      n3 = Constant();
        n0 = new NodeChoice(n3, 1);
      break;
    case STRING_LITERAL:
      n4 = StringLiteral();
        n0 = new NodeChoice(n4, 2);
      break;
    case RBL:
        n5 = new NodeSequence(3);
      n7 = jj_consume_token(RBL);
               n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n8 = Expression();
        n5.addNode(n8);
      n10 = jj_consume_token(RBR);
                n9 = JTBToolkit.makeNodeToken(n10);
        n5.addNode(n9);
        n0 = new NodeChoice(n5, 3);
      break;
    case GENERIC:
      n11 = GenericSelection();
        n0 = new NodeChoice(n11, 4);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new PrimaryExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public GenericSelection GenericSelection() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   AssignmentExpression n4;
   NodeToken n5;
   Token n6;
   GenericAssocList n7;
   NodeToken n8;
   Token n9;
    n1 = jj_consume_token(GENERIC);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = AssignmentExpression();
    n6 = jj_consume_token(COMMA);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = GenericAssocList();
    n9 = jj_consume_token(RBR);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new GenericSelection(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public GenericAssocList GenericAssocList() throws ParseException {
   GenericAssociation n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   GenericAssociation n5;
    n0 = GenericAssociation();
    label_2:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        break label_2;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = GenericAssociation();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new GenericAssocList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public GenericAssociation GenericAssociation() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   TypeName n3;
   NodeToken n4;
   Token n5;
   AssignmentExpression n6;
    switch (jj_nt.kind) {
    case DFAULT:
      n2 = jj_consume_token(DFAULT);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    default:
      if (jj_2_1(1)) {
        n3 = TypeName();
           n0 = new NodeChoice(n3, 1);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    n5 = jj_consume_token(COLON);
            n4 = JTBToolkit.makeNodeToken(n5);
    n6 = AssignmentExpression();
     {if (true) return new GenericAssociation(n0,n4,n6);}
    throw new Error("Missing return statement in function");
  }

  final public PostfixExpression PostfixExpression() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   TypeName n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   InitializerList n9;
   NodeOptional n10 = new NodeOptional();
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeSequence n15;
   PrimaryExpression n16;
   NodeListOptional n17 = new NodeListOptional();
   NodeChoice n18;
   NodeSequence n19;
   NodeToken n20;
   Token n21;
   Expression n22;
   NodeToken n23;
   Token n24;
   NodeSequence n25;
   NodeToken n26;
   Token n27;
   NodeOptional n28;
   ArgumentExpressionList n29;
   NodeToken n30;
   Token n31;
   NodeSequence n32;
   NodeToken n33;
   Token n34;
   NodeToken n35;
   Token n36;
   NodeSequence n37;
   NodeToken n38;
   Token n39;
   NodeToken n40;
   Token n41;
   NodeToken n42;
   Token n43;
   NodeToken n44;
   Token n45;
    if (jj_2_3(2)) {
        n1 = new NodeSequence(8);
      n3 = jj_consume_token(RBL);
               n2 = JTBToolkit.makeNodeToken(n3);
        n1.addNode(n2);
      n4 = TypeName();
        n1.addNode(n4);
      n6 = jj_consume_token(RBR);
               n5 = JTBToolkit.makeNodeToken(n6);
        n1.addNode(n5);
      n8 = jj_consume_token(CBL);
               n7 = JTBToolkit.makeNodeToken(n8);
        n1.addNode(n7);
      n9 = InitializerList();
        n1.addNode(n9);
      switch (jj_nt.kind) {
      case COMMA:
        n12 = jj_consume_token(COMMA);
                   n11 = JTBToolkit.makeNodeToken(n12);
           n10.addNode(n11);
        break;
      default:
        ;
      }
        n1.addNode(n10);
      n14 = jj_consume_token(CBR);
                n13 = JTBToolkit.makeNodeToken(n14);
        n1.addNode(n13);
        n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case GENERIC:
      case IDENTIFIER:
      case RBL:
        n15 = new NodeSequence(2);
        n16 = PrimaryExpression();
        n15.addNode(n16);
        label_3:
        while (true) {
          switch (jj_nt.kind) {
          case INC:
          case DEC:
          case RBL:
          case SBL:
          case DOT:
          case ARROW:
            ;
            break;
          default:
            break label_3;
          }
           n28 = new NodeOptional();
          switch (jj_nt.kind) {
          case SBL:
              n19 = new NodeSequence(3);
            n21 = jj_consume_token(SBL);
                      n20 = JTBToolkit.makeNodeToken(n21);
              n19.addNode(n20);
            n22 = Expression();
              n19.addNode(n22);
            n24 = jj_consume_token(SBR);
                      n23 = JTBToolkit.makeNodeToken(n24);
              n19.addNode(n23);
              n18 = new NodeChoice(n19, 0);
            break;
          case RBL:
              n25 = new NodeSequence(3);
            n27 = jj_consume_token(RBL);
                      n26 = JTBToolkit.makeNodeToken(n27);
              n25.addNode(n26);
            if (jj_2_2(2147483647)) {
              n29 = ArgumentExpressionList();
                 n28.addNode(n29);
            } else {
              ;
            }
              n25.addNode(n28);
            n31 = jj_consume_token(RBR);
                      n30 = JTBToolkit.makeNodeToken(n31);
              n25.addNode(n30);
              n18 = new NodeChoice(n25, 1);
            break;
          case DOT:
              n32 = new NodeSequence(2);
            n34 = jj_consume_token(DOT);
                      n33 = JTBToolkit.makeNodeToken(n34);
              n32.addNode(n33);
            n36 = jj_consume_token(IDENTIFIER);
                               n35 = JTBToolkit.makeNodeToken(n36);
              n32.addNode(n35);
              n18 = new NodeChoice(n32, 2);
            break;
          case ARROW:
              n37 = new NodeSequence(2);
            n39 = jj_consume_token(ARROW);
                               n38 = JTBToolkit.makeNodeToken(n39);
              n37.addNode(n38);
            n41 = jj_consume_token(IDENTIFIER);
                               n40 = JTBToolkit.makeNodeToken(n41);
              n37.addNode(n40);
              n18 = new NodeChoice(n37, 3);
            break;
          case INC:
            n43 = jj_consume_token(INC);
                       n42 = JTBToolkit.makeNodeToken(n43);
              n18 = new NodeChoice(n42, 4);
            break;
          case DEC:
            n45 = jj_consume_token(DEC);
                       n44 = JTBToolkit.makeNodeToken(n45);
              n18 = new NodeChoice(n44, 5);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
           n17.addNode(n18);
        }
        n17.nodes.trimToSize();
        n15.addNode(n17);
        n0 = new NodeChoice(n15, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new PostfixExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ArgumentExpressionList ArgumentExpressionList() throws ParseException {
   AssignmentExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   AssignmentExpression n5;
    n0 = AssignmentExpression();
    label_4:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        break label_4;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = AssignmentExpression();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new ArgumentExpressionList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryExpression UnaryExpression() throws ParseException {
   NodeChoice n0;
   PostfixExpression n1;
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   UnaryExpression n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   UnaryExpression n9;
   NodeSequence n10;
   UnaryOperator n11;
   CastExpression n12;
   NodeSequence n13;
   NodeToken n14;
   Token n15;
   NodeChoice n16;
   NodeSequence n17;
   NodeToken n18;
   Token n19;
   TypeName n20;
   NodeToken n21;
   Token n22;
   UnaryExpression n23;
   NodeSequence n24;
   NodeToken n25;
   Token n26;
   NodeToken n27;
   Token n28;
   TypeName n29;
   NodeToken n30;
   Token n31;
    if (jj_2_5(3)) {
      n1 = PostfixExpression();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case INC:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(INC);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = UnaryExpression();
        n2.addNode(n5);
        n0 = new NodeChoice(n2, 1);
        break;
      case DEC:
        n6 = new NodeSequence(2);
        n8 = jj_consume_token(DEC);
                n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = UnaryExpression();
        n6.addNode(n9);
        n0 = new NodeChoice(n6, 2);
        break;
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n10 = new NodeSequence(2);
        n11 = UnaryOperator();
        n10.addNode(n11);
        n12 = CastExpression();
        n10.addNode(n12);
        n0 = new NodeChoice(n10, 3);
        break;
      case SIZEOF:
        n13 = new NodeSequence(2);
        n15 = jj_consume_token(SIZEOF);
                     n14 = JTBToolkit.makeNodeToken(n15);
        n13.addNode(n14);
        if (jj_2_4(3)) {
              n17 = new NodeSequence(4);
          n19 = jj_consume_token(RBL);
                      n18 = JTBToolkit.makeNodeToken(n19);
              n17.addNode(n18);
          n20 = TypeName();
              n17.addNode(n20);
          n22 = jj_consume_token(RBR);
                      n21 = JTBToolkit.makeNodeToken(n22);
              n17.addNode(n21);
              n16 = new NodeChoice(n17, 0);
        } else {
          switch (jj_nt.kind) {
          case NUMBER:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case ALIGNOF:
          case SIZEOF:
          case GENERIC:
          case IDENTIFIER:
          case INC:
          case DEC:
          case RBL:
          case STAR:
          case PLUS:
          case MINUS:
          case EXCL:
          case AMP:
          case TILDE:
            n23 = UnaryExpression();
              n16 = new NodeChoice(n23, 1);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        n13.addNode(n16);
        n0 = new NodeChoice(n13, 4);
        break;
      case ALIGNOF:
        n24 = new NodeSequence(4);
        n26 = jj_consume_token(ALIGNOF);
                      n25 = JTBToolkit.makeNodeToken(n26);
        n24.addNode(n25);
        n28 = jj_consume_token(RBL);
                n27 = JTBToolkit.makeNodeToken(n28);
        n24.addNode(n27);
        n29 = TypeName();
        n24.addNode(n29);
        n31 = jj_consume_token(RBR);
                n30 = JTBToolkit.makeNodeToken(n31);
        n24.addNode(n30);
        n0 = new NodeChoice(n24, 5);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new UnaryExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public UnaryOperator UnaryOperator() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
    switch (jj_nt.kind) {
    case AMP:
      n2 = jj_consume_token(AMP);
                  n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case STAR:
      n4 = jj_consume_token(STAR);
                  n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    case PLUS:
      n6 = jj_consume_token(PLUS);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
      break;
    case MINUS:
      n8 = jj_consume_token(MINUS);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
      break;
    case TILDE:
      n10 = jj_consume_token(TILDE);
                   n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
      break;
    case EXCL:
      n12 = jj_consume_token(EXCL);
                   n11 = JTBToolkit.makeNodeToken(n12);
           n0 = new NodeChoice(n11, 5);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new UnaryOperator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CastExpression CastExpression() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   TypeName n4;
   NodeToken n5;
   Token n6;
   CastExpression n7;
   UnaryExpression n8;
    if (jj_2_6(2147483647)) {
           n1 = new NodeSequence(5);
      n3 = jj_consume_token(RBL);
                  n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
      n4 = TypeName();
           n1.addNode(n4);
      n6 = jj_consume_token(RBR);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
      n7 = CastExpression();
           n1.addNode(n7);
           n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n8 = UnaryExpression();
           n0 = new NodeChoice(n8, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new CastExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
   CastExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   MultiplicativeExpression n10;
    n0 = CastExpression();
    switch (jj_nt.kind) {
    case STAR:
    case SLASH:
    case MOD:
        n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case STAR:
        n5 = jj_consume_token(STAR);
                     n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
        break;
      case SLASH:
        n7 = jj_consume_token(SLASH);
                     n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
        break;
      case MOD:
        n9 = jj_consume_token(MOD);
                     n8 = JTBToolkit.makeNodeToken(n9);
              n3 = new NodeChoice(n8, 2);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
        n2.addNode(n3);
      n10 = MultiplicativeExpression();
        n2.addNode(n10);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new MultiplicativeExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public AdditiveExpression AdditiveExpression() throws ParseException {
   MultiplicativeExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   AdditiveExpression n8;
    n0 = MultiplicativeExpression();
    switch (jj_nt.kind) {
    case PLUS:
    case MINUS:
        n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case PLUS:
        n5 = jj_consume_token(PLUS);
                     n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
        break;
      case MINUS:
        n7 = jj_consume_token(MINUS);
                     n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
        n2.addNode(n3);
      n8 = AdditiveExpression();
        n2.addNode(n8);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new AdditiveExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ShiftExpression ShiftExpression() throws ParseException {
   AdditiveExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   ShiftExpression n8;
    n0 = AdditiveExpression();
    switch (jj_nt.kind) {
    case LSH:
    case RSH:
        n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case LSH:
        n5 = jj_consume_token(LSH);
                            n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
        break;
      case RSH:
        n7 = jj_consume_token(RSH);
                            n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
        n2.addNode(n3);
      n8 = ShiftExpression();
        n2.addNode(n8);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new ShiftExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public RelationalExpression RelationalExpression() throws ParseException {
   ShiftExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   RelationalExpression n12;
    n0 = ShiftExpression();
    switch (jj_nt.kind) {
    case LESS:
    case GREATER:
    case LE:
    case GE:
        n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case LESS:
        n5 = jj_consume_token(LESS);
                     n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
        break;
      case GREATER:
        n7 = jj_consume_token(GREATER);
                     n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
        break;
      case LE:
        n9 = jj_consume_token(LE);
                           n8 = JTBToolkit.makeNodeToken(n9);
              n3 = new NodeChoice(n8, 2);
        break;
      case GE:
        n11 = jj_consume_token(GE);
                            n10 = JTBToolkit.makeNodeToken(n11);
              n3 = new NodeChoice(n10, 3);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
        n2.addNode(n3);
      n12 = RelationalExpression();
        n2.addNode(n12);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new RelationalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public EqualityExpression EqualityExpression() throws ParseException {
   RelationalExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   EqualityExpression n8;
    n0 = RelationalExpression();
    switch (jj_nt.kind) {
    case EQ:
    case NE:
        n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case EQ:
        n5 = jj_consume_token(EQ);
                           n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
        break;
      case NE:
        n7 = jj_consume_token(NE);
                           n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
        n2.addNode(n3);
      n8 = EqualityExpression();
        n2.addNode(n8);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new EqualityExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ANDExpression ANDExpression() throws ParseException {
   EqualityExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ANDExpression n5;
    n0 = EqualityExpression();
    switch (jj_nt.kind) {
    case AMP:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(AMP);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ANDExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new ANDExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ExclusiveORExpression ExclusiveORExpression() throws ParseException {
   ANDExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ExclusiveORExpression n5;
    n0 = ANDExpression();
    switch (jj_nt.kind) {
    case CARE:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(CARE);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ExclusiveORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new ExclusiveORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public InclusiveORExpression InclusiveORExpression() throws ParseException {
   ExclusiveORExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InclusiveORExpression n5;
    n0 = ExclusiveORExpression();
    switch (jj_nt.kind) {
    case PIPE:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(PIPE);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = InclusiveORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new InclusiveORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public LogicalANDExpression LogicalANDExpression() throws ParseException {
   InclusiveORExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   LogicalANDExpression n5;
    n0 = InclusiveORExpression();
    switch (jj_nt.kind) {
    case LAND:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(LAND);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = LogicalANDExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new LogicalANDExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public LogicalORExpression LogicalORExpression() throws ParseException {
   LogicalANDExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   LogicalORExpression n5;
    n0 = LogicalANDExpression();
    switch (jj_nt.kind) {
    case LOR:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(LOR);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = LogicalORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new LogicalORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ConditionalExpression ConditionalExpression() throws ParseException {
   LogicalORExpression n0;
   NodeOptional n1 = new NodeOptional();
   ConditionalExpressionRightSide n2;
    n0 = LogicalORExpression();
    switch (jj_nt.kind) {
    case QEM:
      n2 = ConditionalExpressionRightSide();
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new ConditionalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ConditionalExpressionRightSide ConditionalExpressionRightSide() throws ParseException {
   NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;
   ConditionalExpression n5;
    n1 = jj_consume_token(QEM);
            n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Expression();
    n4 = jj_consume_token(COLON);
            n3 = JTBToolkit.makeNodeToken(n4);
    n5 = ConditionalExpression();
     {if (true) return new ConditionalExpressionRightSide(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public AssignmentExpression AssignmentExpression() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   UnaryExpression n2;
   AssignmentOperator n3;
   AssignmentExpression n4;
   ConditionalExpression n5;
    if (jj_2_7(2147483647)) {
        n1 = new NodeSequence(4);
      n2 = UnaryExpression();
        n1.addNode(n2);
      n3 = AssignmentOperator();
        n1.addNode(n3);
      n4 = AssignmentExpression();
        n1.addNode(n4);
        n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n5 = ConditionalExpression();
        n0 = new NodeChoice(n5, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new AssignmentExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AssignmentOperator AssignmentOperator() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
    switch (jj_nt.kind) {
    case ASSIGNMENT:
      n2 = jj_consume_token(ASSIGNMENT);
               n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case MULT_EQ:
      n4 = jj_consume_token(MULT_EQ);
                          n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case DIV_EQ:
      n6 = jj_consume_token(DIV_EQ);
                         n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case MOD_EQ:
      n8 = jj_consume_token(MOD_EQ);
                         n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case PLUS_EQ:
      n10 = jj_consume_token(PLUS_EQ);
                           n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case SUB_EQ:
      n12 = jj_consume_token(SUB_EQ);
                          n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    case LSH_EQ:
      n14 = jj_consume_token(LSH_EQ);
                           n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
      break;
    case RSH_EQ:
      n16 = jj_consume_token(RSH_EQ);
                           n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
      break;
    case AND_EQ:
      n18 = jj_consume_token(AND_EQ);
                          n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
      break;
    case XOR_EQ:
      n20 = jj_consume_token(XOR_EQ);
                          n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9);
      break;
    case OR_EQ:
      n22 = jj_consume_token(OR_EQ);
                         n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new AssignmentOperator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Expression Expression() throws ParseException {
   AssignmentExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   AssignmentExpression n5;
    n0 = AssignmentExpression();
    label_5:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        break label_5;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = AssignmentExpression();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new Expression(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ConstantExpression ConstantExpression() throws ParseException {
   ConditionalExpression n0;
    n0 = ConditionalExpression();
     {if (true) return new ConstantExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Declaration Declaration() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   DeclarationSpecifiers n2;
   NodeOptional n3 = new NodeOptional();
   InitDeclaratorList n4;
   NodeOptional n5 = new NodeOptional();
   AttributeSpecifierList n6;
   NodeToken n7;
   Token n8;
   Static_AssertDeclaration n9;
    if (jj_2_8(1)) {
           n1 = new NodeSequence(6);
      n2 = DeclarationSpecifiers();
           n1.addNode(n2);
            lastType = null;
      switch (jj_nt.kind) {
      case IDENTIFIER:
      case RBL:
      case STAR:
        n4 = InitDeclaratorList();
              n3.addNode(n4);
        break;
      default:
        ;
      }
           n1.addNode(n3);
      switch (jj_nt.kind) {
      case ATTRIBUTE:
      case NONNULL:
      case ASM:
        n6 = AttributeSpecifierList();
              n5.addNode(n6);
        break;
      default:
        ;
      }
           n1.addNode(n5);
            if ( !(typedefParsingStack.empty()) && (typedefParsingStack.peek()) )
            {
               typedefParsingStack.pop();
            }
      n8 = jj_consume_token(SEMICOLON);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n1.addNode(n7);
           n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case STATICASSERT:
        n9 = Static_AssertDeclaration();
           n0 = new NodeChoice(n9, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new Declaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public DeclarationSpecifiers DeclarationSpecifiers() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   StorageClassSpecifier n2;
   NodeOptional n3 = new NodeOptional();
   DeclarationSpecifiers n4;
   NodeSequence n5;
   TypeSpecifier n6;
   NodeOptional n7 = new NodeOptional();
   DeclarationSpecifiers n8;
   NodeSequence n9;
   TypeQualifier n10;
   NodeOptional n11 = new NodeOptional();
   DeclarationSpecifiers n12;
   NodeSequence n13;
   FunctionSpecifier n14;
   NodeOptional n15 = new NodeOptional();
   DeclarationSpecifiers n16;
   NodeSequence n17;
   AlignmentSpecifier n18;
   NodeOptional n19 = new NodeOptional();
   DeclarationSpecifiers n20;
   AttributeSpecifier n21;
   NodeOptional n22 = new NodeOptional();
   DeclarationSpecifiers n23;
    switch (jj_nt.kind) {
    case AUTO:
    case EXTERN:
    case REGISTER:
    case STATIC:
    case TYPEDEF:
    case THREADLOCAL:
        n1 = new NodeSequence(2);
      n2 = StorageClassSpecifier();
        n1.addNode(n2);
      if (jj_2_9(2147483647)) {
        n4 = DeclarationSpecifiers();
           n3.addNode(n4);
      } else {
        ;
      }
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0);
      break;
    default:
      if (jj_2_15(2)) {
        n5 = new NodeSequence(3);
        n6 = TypeSpecifier();
        n5.addNode(n6);
        if (jj_2_10(2147483647)) {
          n8 = DeclarationSpecifiers();
           n7.addNode(n8);
        } else {
          ;
        }
        n5.addNode(n7);
        n0 = new NodeChoice(n5, 1);
      } else {
        switch (jj_nt.kind) {
        case CONST:
        case RESTRICT:
        case VOLATILE:
        case ATOMIC:
        n9 = new NodeSequence(2);
          n10 = TypeQualifier();
        n9.addNode(n10);
          if (jj_2_11(2147483647)) {
            n12 = DeclarationSpecifiers();
           n11.addNode(n12);
          } else {
            ;
          }
        n9.addNode(n11);
        n0 = new NodeChoice(n9, 2);
          break;
        case INLINE:
        case NORETURN:
        n13 = new NodeSequence(2);
          n14 = FunctionSpecifier();
        n13.addNode(n14);
          if (jj_2_12(2147483647)) {
            n16 = DeclarationSpecifiers();
           n15.addNode(n16);
          } else {
            ;
          }
        n13.addNode(n15);
        n0 = new NodeChoice(n13, 3);
          break;
        case ALIGNAS:
        n17 = new NodeSequence(4);
          n18 = AlignmentSpecifier();
        n17.addNode(n18);
          if (jj_2_13(2147483647)) {
            n20 = DeclarationSpecifiers();
           n19.addNode(n20);
          } else {
            ;
          }
        n17.addNode(n19);
          n21 = AttributeSpecifier();
        n17.addNode(n21);
          if (jj_2_14(2147483647)) {
            n23 = DeclarationSpecifiers();
           n22.addNode(n23);
          } else {
            ;
          }
        n17.addNode(n22);
        n0 = new NodeChoice(n17, 4);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return new DeclarationSpecifiers(n0);}
    throw new Error("Missing return statement in function");
  }

  final public InitDeclaratorList InitDeclaratorList() throws ParseException {
   InitDeclarator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InitDeclarator n5;
    n0 = InitDeclarator();
    label_6:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        break label_6;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = InitDeclarator();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new InitDeclaratorList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public InitDeclarator InitDeclarator() throws ParseException {
   Declarator n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Initializer n5;
    n0 = Declarator();
    switch (jj_nt.kind) {
    case ASSIGNMENT:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(ASSIGNMENT);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Initializer();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new InitDeclarator(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public StorageClassSpecifier StorageClassSpecifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
    switch (jj_nt.kind) {
    case EXTERN:
      n2 = jj_consume_token(EXTERN);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case STATIC:
      n4 = jj_consume_token(STATIC);
                       n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    case THREADLOCAL:
      n6 = jj_consume_token(THREADLOCAL);
                            n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
      break;
    case AUTO:
      n8 = jj_consume_token(AUTO);
                     n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
      break;
    case REGISTER:
      n10 = jj_consume_token(REGISTER);
                          n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
      break;
    case TYPEDEF:
      n12 = jj_consume_token(TYPEDEF);
                         n11 = JTBToolkit.makeNodeToken(n12);
            typedefParsingStack.push(true);
           n0 = new NodeChoice(n11, 5);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new StorageClassSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TypeSpecifier TypeSpecifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;
   AtomicSpecifier n25;
   StructOrUnionSpecifier n26;
   EnumSpecifier n27;
   TypedefName n28;
    switch (jj_nt.kind) {
    case VOID:
      n2 = jj_consume_token(VOID);
                     n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case CHAR:
      n4 = jj_consume_token(CHAR);
                     n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    case SHORT:
      n6 = jj_consume_token(SHORT);
                      n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
      break;
    case INT:
      n8 = jj_consume_token(INT);
                    n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
      break;
    case LONG:
      n10 = jj_consume_token(LONG);
                      n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
      break;
    case FLOAT:
      n12 = jj_consume_token(FLOAT);
                       n11 = JTBToolkit.makeNodeToken(n12);
           n0 = new NodeChoice(n11, 5);
      break;
    case DOUBLE:
      n14 = jj_consume_token(DOUBLE);
                        n13 = JTBToolkit.makeNodeToken(n14);
           n0 = new NodeChoice(n13, 6);
      break;
    case SIGNED:
      n16 = jj_consume_token(SIGNED);
                        n15 = JTBToolkit.makeNodeToken(n16);
           n0 = new NodeChoice(n15, 7);
      break;
    case UNSIGNED:
      n18 = jj_consume_token(UNSIGNED);
                          n17 = JTBToolkit.makeNodeToken(n18);
           n0 = new NodeChoice(n17, 8);
      break;
    case BOOL:
      n20 = jj_consume_token(BOOL);
                      n19 = JTBToolkit.makeNodeToken(n20);
           n0 = new NodeChoice(n19, 9);
      break;
    case COMPLEX:
      n22 = jj_consume_token(COMPLEX);
                         n21 = JTBToolkit.makeNodeToken(n22);
           n0 = new NodeChoice(n21, 10);
      break;
    case EXTENSION:
      n24 = jj_consume_token(EXTENSION);
                           n23 = JTBToolkit.makeNodeToken(n24);
           n0 = new NodeChoice(n23, 11);
      break;
    case ATOMIC:
      n25 = AtomicSpecifier();
           n0 = new NodeChoice(n25, 12);
      break;
    case STRUCT:
    case UNION:
      n26 = StructOrUnionSpecifier();
           n0 = new NodeChoice(n26, 13);
      break;
    case ENUM:
      n27 = EnumSpecifier();
           n0 = new NodeChoice(n27, 14);
      break;
    default:
      if ((lastType == null || !lastType.equals(getToken(1).image)) && isType(getToken(1).image)) {
        n28 = TypedefName();
            lastType = getToken(0).image;
           n0 = new NodeChoice(n28, 15);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new TypeSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructOrUnionSpecifier StructOrUnionSpecifier() throws ParseException {
   StructOrUnion n0;
   NodeChoice n1;
   NodeSequence n2;
   NodeOptional n3 = new NodeOptional();
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   StructDeclarationList n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
      typedefParsingStack.push(false);
    n0 = StructOrUnion();
    if (jj_2_16(2)) {
           n2 = new NodeSequence(5);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        n5 = jj_consume_token(IDENTIFIER);
                              n4 = JTBToolkit.makeNodeToken(n5);
              n3.addNode(n4);
        break;
      default:
        ;
      }
           n2.addNode(n3);
      n7 = jj_consume_token(CBL);
                  n6 = JTBToolkit.makeNodeToken(n7);
           n2.addNode(n6);
      n8 = StructDeclarationList();
           n2.addNode(n8);
      n10 = jj_consume_token(CBR);
                   n9 = JTBToolkit.makeNodeToken(n10);
           n2.addNode(n9);
           n1 = new NodeChoice(n2, 0);
    } else {
      switch (jj_nt.kind) {
      case IDENTIFIER:
        n12 = jj_consume_token(IDENTIFIER);
                            n11 = JTBToolkit.makeNodeToken(n12);
           n1 = new NodeChoice(n11, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      typedefParsingStack.pop();
     {if (true) return new StructOrUnionSpecifier(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public StructOrUnion StructOrUnion() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch (jj_nt.kind) {
    case STRUCT:
      n2 = jj_consume_token(STRUCT);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case UNION:
      n4 = jj_consume_token(UNION);
                      n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new StructOrUnion(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclarationList StructDeclarationList() throws ParseException {
   NodeList n0 = new NodeList();
   StructDeclaration n1;
    label_7:
    while (true) {
      n1 = StructDeclaration();
        n0.addNode(n1);
      if (jj_2_17(1)) {
        ;
      } else {
        break label_7;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new StructDeclarationList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclaration StructDeclaration() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   SpecifierQualifierList n2;
   NodeOptional n3 = new NodeOptional();
   StructDeclaratorList n4;
   NodeToken n5;
   Token n6;
   Static_AssertDeclaration n7;
    if (jj_2_18(1)) {
           n1 = new NodeSequence(4);
      n2 = SpecifierQualifierList();
           n1.addNode(n2);
            lastType = null;
      switch (jj_nt.kind) {
      case IDENTIFIER:
      case RBL:
      case STAR:
      case COLON:
        n4 = StructDeclaratorList();
              n3.addNode(n4);
        break;
      default:
        ;
      }
           n1.addNode(n3);
      n6 = jj_consume_token(SEMICOLON);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
           n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case STATICASSERT:
        n7 = Static_AssertDeclaration();
           n0 = new NodeChoice(n7, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new StructDeclaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SpecifierQualifierList SpecifierQualifierList() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   TypeSpecifier n2;
   NodeOptional n3 = new NodeOptional();
   SpecifierQualifierList n4;
   NodeSequence n5;
   TypeQualifier n6;
   NodeOptional n7 = new NodeOptional();
   SpecifierQualifierList n8;
    if (jj_2_21(2)) {
        n1 = new NodeSequence(3);
      n2 = TypeSpecifier();
        n1.addNode(n2);
      if (jj_2_19(2147483647)) {
        n4 = SpecifierQualifierList();
           n3.addNode(n4);
      } else {
        ;
      }
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case CONST:
      case RESTRICT:
      case VOLATILE:
      case ATOMIC:
        n5 = new NodeSequence(2);
        n6 = TypeQualifier();
        n5.addNode(n6);
        if (jj_2_20(2147483647)) {
          n8 = SpecifierQualifierList();
           n7.addNode(n8);
        } else {
          ;
        }
        n5.addNode(n7);
        n0 = new NodeChoice(n5, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new SpecifierQualifierList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclaratorList StructDeclaratorList() throws ParseException {
   StructDeclarator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   StructDeclarator n5;
    n0 = StructDeclarator();
    label_8:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        break label_8;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = StructDeclarator();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new StructDeclaratorList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public StructDeclarator StructDeclarator() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   Declarator n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   ConstantExpression n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   ConstantExpression n11;
    switch (jj_nt.kind) {
    case IDENTIFIER:
    case RBL:
    case STAR:
        n1 = new NodeSequence(2);
      n2 = Declarator();
        n1.addNode(n2);
      switch (jj_nt.kind) {
      case COLON:
           n4 = new NodeSequence(2);
        n6 = jj_consume_token(COLON);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n4.addNode(n5);
        n7 = ConstantExpression();
           n4.addNode(n7);
           n3.addNode(n4);
        break;
      default:
        ;
      }
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0);
      break;
    case COLON:
        n8 = new NodeSequence(2);
      n10 = jj_consume_token(COLON);
                n9 = JTBToolkit.makeNodeToken(n10);
        n8.addNode(n9);
      n11 = ConstantExpression();
        n8.addNode(n11);
        n0 = new NodeChoice(n8, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new StructDeclarator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public EnumSpecifier EnumSpecifier() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeChoice n2;
   NodeSequence n3;
   NodeOptional n4 = new NodeOptional();
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   EnumeratorList n9;
   NodeOptional n10 = new NodeOptional();
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
    n1 = jj_consume_token(ENUM);
               n0 = JTBToolkit.makeNodeToken(n1);
    if (jj_2_22(3)) {
           n3 = new NodeSequence(6);
      switch (jj_nt.kind) {
      case IDENTIFIER:
        n6 = jj_consume_token(IDENTIFIER);
                              n5 = JTBToolkit.makeNodeToken(n6);
              n4.addNode(n5);
        break;
      default:
        ;
      }
           n3.addNode(n4);
      n8 = jj_consume_token(CBL);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n3.addNode(n7);
      n9 = EnumeratorList();
           n3.addNode(n9);
      switch (jj_nt.kind) {
      case COMMA:
        n12 = jj_consume_token(COMMA);
                      n11 = JTBToolkit.makeNodeToken(n12);
              n10.addNode(n11);
        break;
      default:
        ;
      }
           n3.addNode(n10);
      n14 = jj_consume_token(CBR);
                   n13 = JTBToolkit.makeNodeToken(n14);
           n3.addNode(n13);
           n2 = new NodeChoice(n3, 0);
    } else {
      switch (jj_nt.kind) {
      case IDENTIFIER:
        n16 = jj_consume_token(IDENTIFIER);
                            n15 = JTBToolkit.makeNodeToken(n16);
           n2 = new NodeChoice(n15, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new EnumSpecifier(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public EnumeratorList EnumeratorList() throws ParseException {
   Enumerator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Enumerator n5;
    n0 = Enumerator();
    label_9:
    while (true) {
      if (jj_2_23(2)) {
        ;
      } else {
        break label_9;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Enumerator();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new EnumeratorList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public Enumerator Enumerator() throws ParseException {
   EnumerationConstant n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ConstantExpression n5;
    n0 = EnumerationConstant();
    switch (jj_nt.kind) {
    case ASSIGNMENT:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(ASSIGNMENT);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ConstantExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new Enumerator(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public AtomicSpecifier AtomicSpecifier() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   TypedefName n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(ATOMIC);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    if (isType(getToken(1).image)) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    n4 = TypedefName();
    n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new AtomicSpecifier(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public TypeQualifier TypeQualifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
    switch (jj_nt.kind) {
    case CONST:
      n2 = jj_consume_token(CONST);
                      n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case RESTRICT:
      n4 = jj_consume_token(RESTRICT);
                         n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    case VOLATILE:
      n6 = jj_consume_token(VOLATILE);
                         n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
      break;
    case ATOMIC:
      n8 = jj_consume_token(ATOMIC);
                       n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new TypeQualifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FunctionSpecifier FunctionSpecifier() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
    switch (jj_nt.kind) {
    case INLINE:
      n2 = jj_consume_token(INLINE);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
      break;
    case NORETURN:
      n4 = jj_consume_token(NORETURN);
                         n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new FunctionSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AlignmentSpecifier AlignmentSpecifier() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeChoice n4;
   TypedefName n5;
   ConstantExpression n6;
   NodeToken n7;
   Token n8;
    n1 = jj_consume_token(ALIGNAS);
                  n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    if (isType(getToken(1).image)) {
      n5 = TypedefName();
           n4 = new NodeChoice(n5, 0);
    } else {
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n6 = ConstantExpression();
           n4 = new NodeChoice(n6, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    n8 = jj_consume_token(RBR);
            n7 = JTBToolkit.makeNodeToken(n8);
     {if (true) return new AlignmentSpecifier(n0,n2,n4,n7);}
    throw new Error("Missing return statement in function");
  }

  final public Declarator Declarator() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   Pointer n1;
   DirectDeclarator n2;
    switch (jj_nt.kind) {
    case STAR:
      n1 = Pointer();
        n0.addNode(n1);
      break;
    default:
      ;
    }
    n2 = DirectDeclarator();
     {if (true) return new Declarator(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public DirectDeclarator DirectDeclarator() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   Declarator n6;
   NodeToken n7;
   Token n8;
   NodeListOptional n9 = new NodeListOptional();
   NodeChoice n10;
   NodeSequence n11;
   NodeToken n12;
   Token n13;
   NodeChoice n14;
   NodeSequence n15;
   NodeToken n16;
   Token n17;
   NodeOptional n18;
   TypeQualifierList n19;
   AssignmentExpression n20;
   NodeSequence n21;
   TypeQualifierList n22;
   NodeToken n23;
   Token n24;
   AssignmentExpression n25;
   NodeSequence n26;
   NodeOptional n27;
   TypeQualifierList n28;
   NodeToken n29;
   Token n30;
   NodeToken n31;
   Token n32;
   NodeOptional n33;
   ConstantExpression n34;
   NodeToken n35;
   Token n36;
   NodeSequence n37;
   NodeToken n38;
   Token n39;
   ParameterTypeList n40;
   NodeToken n41;
   Token n42;
   NodeSequence n43;
   NodeToken n44;
   Token n45;
   NodeOptional n46;
   IdentifierList n47;
   NodeToken n48;
   Token n49;

   Token t;
    switch (jj_nt.kind) {
    case IDENTIFIER:
      t = n2 = jj_consume_token(IDENTIFIER);
                          n1 = JTBToolkit.makeNodeToken(n2);
            addDecl(t.image,!(typedefParsingStack.empty()) && (typedefParsingStack.peek()));
           n0 = new NodeChoice(n1, 0);
      break;
    case RBL:
           n3 = new NodeSequence(3);
      n5 = jj_consume_token(RBL);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
      n6 = Declarator();
           n3.addNode(n6);
      n8 = jj_consume_token(RBR);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n3.addNode(n7);
           n0 = new NodeChoice(n3, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
      typedefParsingStack.push(false);
    label_10:
    while (true) {
      switch (jj_nt.kind) {
      case RBL:
      case SBL:
        ;
        break;
      default:
        break label_10;
      }
        n18 = new NodeOptional();
        n27 = new NodeOptional();
        n33 = new NodeOptional();
        n46 = new NodeOptional();
      switch (jj_nt.kind) {
      case SBL:
           n11 = new NodeSequence(3);
        n13 = jj_consume_token(SBL);
                   n12 = JTBToolkit.makeNodeToken(n13);
           n11.addNode(n12);
        switch (jj_nt.kind) {
        case STATIC:
                 n15 = new NodeSequence(3);
          n17 = jj_consume_token(STATIC);
                              n16 = JTBToolkit.makeNodeToken(n17);
                 n15.addNode(n16);
          switch (jj_nt.kind) {
          case CONST:
          case RESTRICT:
          case VOLATILE:
          case ATOMIC:
            n19 = TypeQualifierList();
                    n18.addNode(n19);
            break;
          default:
            ;
          }
                 n15.addNode(n18);
          n20 = AssignmentExpression();
                 n15.addNode(n20);
                 n14 = new NodeChoice(n15, 0);
          break;
        default:
          if (jj_2_24(2147483647)) {
                 n21 = new NodeSequence(4);
            n22 = TypeQualifierList();
                 n21.addNode(n22);
            n24 = jj_consume_token(STATIC);
                              n23 = JTBToolkit.makeNodeToken(n24);
                 n21.addNode(n23);
            n25 = AssignmentExpression();
                 n21.addNode(n25);
                 n14 = new NodeChoice(n21, 1);
          } else if (jj_2_25(2)) {
                 n26 = new NodeSequence(4);
            switch (jj_nt.kind) {
            case CONST:
            case RESTRICT:
            case VOLATILE:
            case ATOMIC:
              n28 = TypeQualifierList();
                    n27.addNode(n28);
              break;
            default:
              ;
            }
                 n26.addNode(n27);
            n30 = jj_consume_token(STAR);
                         n29 = JTBToolkit.makeNodeToken(n30);
                 n26.addNode(n29);
            n32 = jj_consume_token(SBR);
                         n31 = JTBToolkit.makeNodeToken(n32);
                 n26.addNode(n31);
                 n14 = new NodeChoice(n26, 2);
          } else {
            switch (jj_nt.kind) {
            case NUMBER:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case ALIGNOF:
            case SIZEOF:
            case GENERIC:
            case IDENTIFIER:
            case INC:
            case DEC:
            case RBL:
            case STAR:
            case PLUS:
            case MINUS:
            case EXCL:
            case AMP:
            case TILDE:
              n34 = ConstantExpression();
                    n33.addNode(n34);
              break;
            default:
              ;
            }
                 n14 = new NodeChoice(n33, 3);
          }
        }
           n11.addNode(n14);
        n36 = jj_consume_token(SBR);
                   n35 = JTBToolkit.makeNodeToken(n36);
           n11.addNode(n35);
           n10 = new NodeChoice(n11, 0);
        break;
      default:
        if (jj_2_26(3)) {
           n37 = new NodeSequence(4);
          n39 = jj_consume_token(RBL);
                   n38 = JTBToolkit.makeNodeToken(n39);
           n37.addNode(n38);
          n40 = ParameterTypeList();
           n37.addNode(n40);
          n42 = jj_consume_token(RBR);
                   n41 = JTBToolkit.makeNodeToken(n42);
           n37.addNode(n41);
           n10 = new NodeChoice(n37, 1);
        } else {
          switch (jj_nt.kind) {
          case RBL:
           n43 = new NodeSequence(3);
            n45 = jj_consume_token(RBL);
                   n44 = JTBToolkit.makeNodeToken(n45);
           n43.addNode(n44);
            switch (jj_nt.kind) {
            case IDENTIFIER:
              n47 = IdentifierList();
              n46.addNode(n47);
              break;
            default:
              ;
            }
           n43.addNode(n46);
            n49 = jj_consume_token(RBR);
                   n48 = JTBToolkit.makeNodeToken(n49);
           n43.addNode(n48);
           n10 = new NodeChoice(n43, 2);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
        n9.addNode(n10);
    }
     n9.nodes.trimToSize();
      typedefParsingStack.pop();
     {if (true) return new DirectDeclarator(n0,n9);}
    throw new Error("Missing return statement in function");
  }

  final public Pointer Pointer() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   TypeQualifierList n3;
   NodeOptional n4 = new NodeOptional();
   Pointer n5;
    n1 = jj_consume_token(STAR);
            n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case CONST:
    case RESTRICT:
    case VOLATILE:
    case ATOMIC:
      n3 = TypeQualifierList();
        n2.addNode(n3);
      break;
    default:
      ;
    }
    switch (jj_nt.kind) {
    case STAR:
      n5 = Pointer();
        n4.addNode(n5);
      break;
    default:
      ;
    }
     {if (true) return new Pointer(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public TypeQualifierList TypeQualifierList() throws ParseException {
   NodeList n0 = new NodeList();
   TypeQualifier n1;
    label_11:
    while (true) {
      n1 = TypeQualifier();
        n0.addNode(n1);
      switch (jj_nt.kind) {
      case CONST:
      case RESTRICT:
      case VOLATILE:
      case ATOMIC:
        ;
        break;
      default:
        break label_11;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new TypeQualifierList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterTypeList ParameterTypeList() throws ParseException {
   ParameterList n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
    n0 = ParameterList();
    switch (jj_nt.kind) {
    case COMMA:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n6 = jj_consume_token(ELLIPSIS);
                            n5 = JTBToolkit.makeNodeToken(n6);
        n2.addNode(n5);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new ParameterTypeList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterList ParameterList() throws ParseException {
   ParameterDeclaration n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ParameterDeclaration n5;
    n0 = ParameterDeclaration();
    label_12:
    while (true) {
      if (jj_2_27(2)) {
        ;
      } else {
        break label_12;
      }
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = ParameterDeclaration();
        n2.addNode(n5);
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new ParameterList(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public ParameterDeclaration ParameterDeclaration() throws ParseException {
   DeclarationSpecifiers n0;
   NodeChoice n1;
   Declarator n2;
   NodeOptional n3 = new NodeOptional();
   AbstractDeclarator n4;
    n0 = DeclarationSpecifiers();
      lastType = null;
    if (jj_2_28(2147483647)) {
      n2 = Declarator();
           n1 = new NodeChoice(n2, 0);
    } else {
      switch (jj_nt.kind) {
      case RBL:
      case SBL:
      case STAR:
        n4 = AbstractDeclarator();
              n3.addNode(n4);
        break;
      default:
        ;
      }
           n1 = new NodeChoice(n3, 1);
    }
     {if (true) return new ParameterDeclaration(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public IdentifierList IdentifierList() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
    label_13:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        break label_13;
      }
        n3 = new NodeSequence(2);
      n5 = jj_consume_token(COMMA);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      n7 = jj_consume_token(IDENTIFIER);
                        n6 = JTBToolkit.makeNodeToken(n7);
        n3.addNode(n6);
        n2.addNode(n3);
    }
     n2.nodes.trimToSize();
     {if (true) return new IdentifierList(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public TypeName TypeName() throws ParseException {
   SpecifierQualifierList n0;
   NodeOptional n1 = new NodeOptional();
   AbstractDeclarator n2;
    n0 = SpecifierQualifierList();
      lastType = null;
    switch (jj_nt.kind) {
    case RBL:
    case SBL:
    case STAR:
      n2 = AbstractDeclarator();
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new TypeName(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public AbstractDeclarator AbstractDeclarator() throws ParseException {
   NodeChoice n0;
   Pointer n1;
   NodeSequence n2;
   NodeOptional n3 = new NodeOptional();
   Pointer n4;
   DirectAbstractDeclarator n5;
    if (jj_2_29(3)) {
      n1 = Pointer();
           n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case RBL:
      case SBL:
      case STAR:
           n2 = new NodeSequence(2);
        switch (jj_nt.kind) {
        case STAR:
          n4 = Pointer();
              n3.addNode(n4);
          break;
        default:
          ;
        }
           n2.addNode(n3);
        n5 = DirectAbstractDeclarator();
           n2.addNode(n5);
           n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new AbstractDeclarator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public DirectAbstractDeclarator DirectAbstractDeclarator() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   AbstractDeclarator n4;
   NodeToken n5;
   Token n6;
   NodeSequence n7;
   NodeToken n8;
   Token n9;
   NodeOptional n10 = new NodeOptional();
   ParameterTypeList n11;
   NodeToken n12;
   Token n13;
   NodeSequence n14;
   NodeToken n15;
   Token n16;
   NodeChoice n17;
   NodeSequence n18;
   NodeToken n19;
   Token n20;
   NodeOptional n21 = new NodeOptional();
   TypeQualifierList n22;
   AssignmentExpression n23;
   NodeSequence n24;
   TypeQualifierList n25;
   NodeToken n26;
   Token n27;
   AssignmentExpression n28;
   NodeToken n29;
   Token n30;
   NodeSequence n31;
   NodeOptional n32 = new NodeOptional();
   TypeQualifierList n33;
   AssignmentExpression n34;
   NodeToken n35;
   Token n36;
   NodeListOptional n37 = new NodeListOptional();
   NodeChoice n38;
   NodeSequence n39;
   NodeToken n40;
   Token n41;
   NodeOptional n42;
   ParameterTypeList n43;
   NodeToken n44;
   Token n45;
   NodeSequence n46;
   NodeToken n47;
   Token n48;
   NodeChoice n49;
   NodeSequence n50;
   NodeToken n51;
   Token n52;
   NodeOptional n53;
   TypeQualifierList n54;
   AssignmentExpression n55;
   NodeSequence n56;
   TypeQualifierList n57;
   NodeToken n58;
   Token n59;
   AssignmentExpression n60;
   NodeToken n61;
   Token n62;
   NodeSequence n63;
   NodeOptional n64;
   TypeQualifierList n65;
   AssignmentExpression n66;
   NodeToken n67;
   Token n68;
    if (jj_2_33(2)) {
           n1 = new NodeSequence(4);
      n3 = jj_consume_token(RBL);
                  n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
      n4 = AbstractDeclarator();
           n1.addNode(n4);
      n6 = jj_consume_token(RBR);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
           n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case RBL:
           n7 = new NodeSequence(3);
        n9 = jj_consume_token(RBL);
                  n8 = JTBToolkit.makeNodeToken(n9);
           n7.addNode(n8);
        if (jj_2_30(1)) {
          n11 = ParameterTypeList();
              n10.addNode(n11);
        } else {
          ;
        }
           n7.addNode(n10);
        n13 = jj_consume_token(RBR);
                   n12 = JTBToolkit.makeNodeToken(n13);
           n7.addNode(n12);
           n0 = new NodeChoice(n7, 1);
        break;
      case SBL:
           n14 = new NodeSequence(3);
        n16 = jj_consume_token(SBL);
                   n15 = JTBToolkit.makeNodeToken(n16);
           n14.addNode(n15);
        switch (jj_nt.kind) {
        case STATIC:
                 n18 = new NodeSequence(3);
          n20 = jj_consume_token(STATIC);
                              n19 = JTBToolkit.makeNodeToken(n20);
                 n18.addNode(n19);
          switch (jj_nt.kind) {
          case CONST:
          case RESTRICT:
          case VOLATILE:
          case ATOMIC:
            n22 = TypeQualifierList();
                    n21.addNode(n22);
            break;
          default:
            ;
          }
                 n18.addNode(n21);
          n23 = AssignmentExpression();
                 n18.addNode(n23);
                 n17 = new NodeChoice(n18, 0);
          break;
        default:
          if (jj_2_31(2147483647)) {
                 n24 = new NodeSequence(4);
            n25 = TypeQualifierList();
                 n24.addNode(n25);
            n27 = jj_consume_token(STATIC);
                              n26 = JTBToolkit.makeNodeToken(n27);
                 n24.addNode(n26);
            n28 = AssignmentExpression();
                 n24.addNode(n28);
                 n17 = new NodeChoice(n24, 1);
          } else if (jj_2_32(2)) {
            n30 = jj_consume_token(STAR);
                         n29 = JTBToolkit.makeNodeToken(n30);
                 n17 = new NodeChoice(n29, 2);
          } else {
            switch (jj_nt.kind) {
            case NUMBER:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case ALIGNOF:
            case CONST:
            case RESTRICT:
            case SIZEOF:
            case VOLATILE:
            case ATOMIC:
            case GENERIC:
            case IDENTIFIER:
            case INC:
            case DEC:
            case RBL:
            case STAR:
            case PLUS:
            case MINUS:
            case EXCL:
            case AMP:
            case TILDE:
                 n31 = new NodeSequence(2);
              switch (jj_nt.kind) {
              case CONST:
              case RESTRICT:
              case VOLATILE:
              case ATOMIC:
                n33 = TypeQualifierList();
                    n32.addNode(n33);
                break;
              default:
                ;
              }
                 n31.addNode(n32);
              n34 = AssignmentExpression();
                 n31.addNode(n34);
                 n17 = new NodeChoice(n31, 3);
              break;
            default:
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
           n14.addNode(n17);
        n36 = jj_consume_token(SBR);
                   n35 = JTBToolkit.makeNodeToken(n36);
           n14.addNode(n35);
           n0 = new NodeChoice(n14, 2);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_14:
    while (true) {
      switch (jj_nt.kind) {
      case RBL:
      case SBL:
        ;
        break;
      default:
        break label_14;
      }
        n42 = new NodeOptional();
        n53 = new NodeOptional();
        n64 = new NodeOptional();
      switch (jj_nt.kind) {
      case RBL:
           n39 = new NodeSequence(3);
        n41 = jj_consume_token(RBL);
                   n40 = JTBToolkit.makeNodeToken(n41);
           n39.addNode(n40);
        if (jj_2_34(1)) {
          n43 = ParameterTypeList();
              n42.addNode(n43);
        } else {
          ;
        }
           n39.addNode(n42);
        n45 = jj_consume_token(RBR);
                   n44 = JTBToolkit.makeNodeToken(n45);
           n39.addNode(n44);
           n38 = new NodeChoice(n39, 0);
        break;
      case SBL:
           n46 = new NodeSequence(3);
        n48 = jj_consume_token(SBL);
                   n47 = JTBToolkit.makeNodeToken(n48);
           n46.addNode(n47);
        switch (jj_nt.kind) {
        case STATIC:
                 n50 = new NodeSequence(3);
          n52 = jj_consume_token(STATIC);
                              n51 = JTBToolkit.makeNodeToken(n52);
                 n50.addNode(n51);
          switch (jj_nt.kind) {
          case CONST:
          case RESTRICT:
          case VOLATILE:
          case ATOMIC:
            n54 = TypeQualifierList();
                    n53.addNode(n54);
            break;
          default:
            ;
          }
                 n50.addNode(n53);
          n55 = AssignmentExpression();
                 n50.addNode(n55);
                 n49 = new NodeChoice(n50, 0);
          break;
        default:
          if (jj_2_35(2147483647)) {
                 n56 = new NodeSequence(4);
            n57 = TypeQualifierList();
                 n56.addNode(n57);
            n59 = jj_consume_token(STATIC);
                              n58 = JTBToolkit.makeNodeToken(n59);
                 n56.addNode(n58);
            n60 = AssignmentExpression();
                 n56.addNode(n60);
                 n49 = new NodeChoice(n56, 1);
          } else if (jj_2_36(2)) {
            n62 = jj_consume_token(STAR);
                         n61 = JTBToolkit.makeNodeToken(n62);
                 n49 = new NodeChoice(n61, 2);
          } else {
            switch (jj_nt.kind) {
            case NUMBER:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case ALIGNOF:
            case CONST:
            case RESTRICT:
            case SIZEOF:
            case VOLATILE:
            case ATOMIC:
            case GENERIC:
            case IDENTIFIER:
            case INC:
            case DEC:
            case RBL:
            case STAR:
            case PLUS:
            case MINUS:
            case EXCL:
            case AMP:
            case TILDE:
                 n63 = new NodeSequence(2);
              switch (jj_nt.kind) {
              case CONST:
              case RESTRICT:
              case VOLATILE:
              case ATOMIC:
                n65 = TypeQualifierList();
                    n64.addNode(n65);
                break;
              default:
                ;
              }
                 n63.addNode(n64);
              n66 = AssignmentExpression();
                 n63.addNode(n66);
                 n49 = new NodeChoice(n63, 3);
              break;
            default:
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
           n46.addNode(n49);
        n68 = jj_consume_token(SBR);
                   n67 = JTBToolkit.makeNodeToken(n68);
           n46.addNode(n67);
           n38 = new NodeChoice(n46, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
        n37.addNode(n38);
    }
     n37.nodes.trimToSize();
     {if (true) return new DirectAbstractDeclarator(n0,n37);}
    throw new Error("Missing return statement in function");
  }

  final public TypedefName TypedefName() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new TypedefName(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Initializer Initializer() throws ParseException {
   NodeChoice n0;
   AssignmentExpression n1;
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InitializerList n5;
   NodeOptional n6 = new NodeOptional();
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
    switch (jj_nt.kind) {
    case NUMBER:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case ALIGNOF:
    case SIZEOF:
    case GENERIC:
    case IDENTIFIER:
    case INC:
    case DEC:
    case RBL:
    case STAR:
    case PLUS:
    case MINUS:
    case EXCL:
    case AMP:
    case TILDE:
      n1 = AssignmentExpression();
           n0 = new NodeChoice(n1, 0);
      break;
    case CBL:
           n2 = new NodeSequence(4);
      n4 = jj_consume_token(CBL);
                  n3 = JTBToolkit.makeNodeToken(n4);
           n2.addNode(n3);
      n5 = InitializerList();
           n2.addNode(n5);
      switch (jj_nt.kind) {
      case COMMA:
        n8 = jj_consume_token(COMMA);
                     n7 = JTBToolkit.makeNodeToken(n8);
              n6.addNode(n7);
        break;
      default:
        ;
      }
           n2.addNode(n6);
      n10 = jj_consume_token(CBR);
                   n9 = JTBToolkit.makeNodeToken(n10);
           n2.addNode(n9);
           n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Initializer(n0);}
    throw new Error("Missing return statement in function");
  }

  final public InitializerList InitializerList() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   Designation n1;
   Initializer n2;
   NodeListOptional n3 = new NodeListOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   Initializer n7;
    switch (jj_nt.kind) {
    case SBL:
    case DOT:
      n1 = Designation();
        n0.addNode(n1);
      break;
    default:
      ;
    }
    n2 = Initializer();
    label_15:
    while (true) {
      if (jj_2_37(2)) {
        ;
      } else {
        break label_15;
      }
        n4 = new NodeSequence(2);
      n6 = jj_consume_token(COMMA);
               n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
      n7 = Initializer();
        n4.addNode(n7);
        n3.addNode(n4);
    }
     n3.nodes.trimToSize();
     {if (true) return new InitializerList(n0,n2,n3);}
    throw new Error("Missing return statement in function");
  }

  final public Designation Designation() throws ParseException {
   DesignatorList n0;
   NodeToken n1;
   Token n2;
    n0 = DesignatorList();
    n2 = jj_consume_token(ASSIGNMENT);
            n1 = JTBToolkit.makeNodeToken(n2);
     {if (true) return new Designation(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public DesignatorList DesignatorList() throws ParseException {
   NodeList n0 = new NodeList();
   Designator n1;
    label_16:
    while (true) {
      n1 = Designator();
        n0.addNode(n1);
      switch (jj_nt.kind) {
      case SBL:
      case DOT:
        ;
        break;
      default:
        break label_16;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new DesignatorList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Designator Designator() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
   NodeToken n5;
   Token n6;
   NodeSequence n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    switch (jj_nt.kind) {
    case SBL:
           n1 = new NodeSequence(3);
      n3 = jj_consume_token(SBL);
                  n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
      n4 = ConstantExpression();
           n1.addNode(n4);
      n6 = jj_consume_token(SBR);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
           n0 = new NodeChoice(n1, 0);
      break;
    case DOT:
           n7 = new NodeSequence(2);
      n9 = jj_consume_token(DOT);
                  n8 = JTBToolkit.makeNodeToken(n9);
           n7.addNode(n8);
      n11 = jj_consume_token(IDENTIFIER);
                            n10 = JTBToolkit.makeNodeToken(n11);
           n7.addNode(n10);
           n0 = new NodeChoice(n7, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Designator(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Static_AssertDeclaration Static_AssertDeclaration() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
   NodeToken n5;
   Token n6;
   StringLiteral n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(STATICASSERT);
                       n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ConstantExpression();
    n6 = jj_consume_token(COMMA);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = StringLiteral();
    n9 = jj_consume_token(RBR);
            n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(SEMICOLON);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new Static_AssertDeclaration(n0,n2,n4,n5,n7,n8,n10);}
    throw new Error("Missing return statement in function");
  }

  final public Statement Statement() throws ParseException {
   NodeChoice n0;
   LabeledStatement n1;
   CompoundStatement n2;
   ExpressionStatement n3;
   IfStatement n4;
   SwitchStatement n5;
   WhileStatement n6;
   DoStatement n7;
   ForStatement n8;
   JumpStatement n9;
    if (jj_2_38(2)) {
      n1 = LabeledStatement();
           n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case CBL:
        n2 = CompoundStatement();
           n0 = new NodeChoice(n2, 1);
        break;
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
      case SEMICOLON:
        n3 = ExpressionStatement();
           n0 = new NodeChoice(n3, 2);
        break;
      case IF:
        n4 = IfStatement();
           n0 = new NodeChoice(n4, 3);
        break;
      case SWITCH:
        n5 = SwitchStatement();
           n0 = new NodeChoice(n5, 4);
        break;
      case WHILE:
        n6 = WhileStatement();
           n0 = new NodeChoice(n6, 5);
        break;
      case DO:
        n7 = DoStatement();
           n0 = new NodeChoice(n7, 6);
        break;
      case FOR:
        n8 = ForStatement();
           n0 = new NodeChoice(n8, 7);
        break;
      case BREAK:
      case CONTINUE:
      case GOTO:
      case RETURN:
        n9 = JumpStatement();
           n0 = new NodeChoice(n9, 8);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new Statement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public LabeledStatement LabeledStatement() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeOptional n6 = new NodeOptional();
   AttributeSpecifierList n7;
   Statement n8;
   CaseStatement n9;
   DefaultStatement n10;
    switch (jj_nt.kind) {
    case IDENTIFIER:
           n1 = new NodeSequence(4);
      n3 = jj_consume_token(IDENTIFIER);
                           n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
      n5 = jj_consume_token(COLON);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n1.addNode(n4);
      switch (jj_nt.kind) {
      case ATTRIBUTE:
      case NONNULL:
      case ASM:
        n7 = AttributeSpecifierList();
              n6.addNode(n7);
        break;
      default:
        ;
      }
           n1.addNode(n6);
      n8 = Statement();
           n1.addNode(n8);
           n0 = new NodeChoice(n1, 0);
      break;
    case CASE:
      n9 = CaseStatement();
           n0 = new NodeChoice(n9, 1);
      break;
    case DFAULT:
      n10 = DefaultStatement();
           n0 = new NodeChoice(n10, 2);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new LabeledStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CaseStatement CaseStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   ConstantExpression n2;
   NodeToken n3;
   Token n4;
   Statement n5;
    n1 = jj_consume_token(CASE);
               n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ConstantExpression();
    n4 = jj_consume_token(COLON);
            n3 = JTBToolkit.makeNodeToken(n4);
    n5 = Statement();
     {if (true) return new CaseStatement(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public DefaultStatement DefaultStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Statement n4;
    n1 = jj_consume_token(DFAULT);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(COLON);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Statement();
     {if (true) return new DefaultStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public CompoundStatement CompoundStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   BlockItemList n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(CBL);
            n0 = JTBToolkit.makeNodeToken(n1);
      startScope();
    if (jj_2_39(1)) {
      n3 = BlockItemList();
        n2.addNode(n3);
    } else {
      ;
    }
      endScope();
    n5 = jj_consume_token(CBR);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new CompoundStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public BlockItemList BlockItemList() throws ParseException {
   NodeList n0 = new NodeList();
   BlockItem n1;
    label_17:
    while (true) {
      n1 = BlockItem();
        n0.addNode(n1);
      if (jj_2_40(1)) {
        ;
      } else {
        break label_17;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new BlockItemList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BlockItem BlockItem() throws ParseException {
   NodeChoice n0;
   Declaration n1;
   Statement n2;
    if (jj_2_41(1)) {
      n1 = Declaration();
        n0 = new NodeChoice(n1, 0);
    } else {
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case BREAK:
      case CASE:
      case CONTINUE:
      case DFAULT:
      case DO:
      case FOR:
      case GOTO:
      case IF:
      case RETURN:
      case SIZEOF:
      case SWITCH:
      case WHILE:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case CBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
      case SEMICOLON:
        n2 = Statement();
        n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return new BlockItem(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionStatement ExpressionStatement() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   Expression n1;
   NodeToken n2;
   Token n3;
    switch (jj_nt.kind) {
    case NUMBER:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case ALIGNOF:
    case SIZEOF:
    case GENERIC:
    case IDENTIFIER:
    case INC:
    case DEC:
    case RBL:
    case STAR:
    case PLUS:
    case MINUS:
    case EXCL:
    case AMP:
    case TILDE:
      n1 = Expression();
        n0.addNode(n1);
      break;
    default:
      ;
    }
    n3 = jj_consume_token(SEMICOLON);
            n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new ExpressionStatement(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public IfStatement IfStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
   NodeOptional n8 = new NodeOptional();
   NodeSequence n9;
   NodeToken n10;
   Token n11;
   Statement n12;
    n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
    if (jj_2_42(2)) {
        n9 = new NodeSequence(2);
      n11 = jj_consume_token(ELSE);
                   n10 = JTBToolkit.makeNodeToken(n11);
        n9.addNode(n10);
      n12 = Statement();
        n9.addNode(n12);
        n8.addNode(n9);
    } else {
      ;
    }
     {if (true) return new IfStatement(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  final public SwitchStatement SwitchStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
    n1 = jj_consume_token(SWITCH);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
     {if (true) return new SwitchStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public WhileStatement WhileStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
    n1 = jj_consume_token(WHILE);
                n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Expression();
    n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Statement();
     {if (true) return new WhileStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
  }

  final public DoStatement DoStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   Statement n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   Expression n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(DO);
             n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Statement();
    n4 = jj_consume_token(WHILE);
                n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(RBL);
            n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Expression();
    n9 = jj_consume_token(RBR);
            n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(SEMICOLON);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new DoStatement(n0,n2,n3,n5,n7,n8,n10);}
    throw new Error("Missing return statement in function");
  }

  final public ForStatement ForStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeChoice n4;
   NodeSequence n5;
   Declaration n6;
   NodeOptional n7 = new NodeOptional();
   Expression n8;
   NodeSequence n9;
   NodeOptional n10 = new NodeOptional();
   Expression n11;
   NodeToken n12;
   Token n13;
   NodeOptional n14 = new NodeOptional();
   Expression n15;
   NodeToken n16;
   Token n17;
   NodeOptional n18 = new NodeOptional();
   Expression n19;
   NodeToken n20;
   Token n21;
   Statement n22;
    n1 = jj_consume_token(FOR);
              n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    if (jj_2_43(2147483647)) {
           n5 = new NodeSequence(3);
      n6 = Declaration();
           n5.addNode(n6);
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n8 = Expression();
              n7.addNode(n8);
        break;
      default:
        ;
      }
           n5.addNode(n7);
           n4 = new NodeChoice(n5, 0);
    } else {
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
      case SEMICOLON:
           n9 = new NodeSequence(3);
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
          n11 = Expression();
              n10.addNode(n11);
          break;
        default:
          ;
        }
           n9.addNode(n10);
        n13 = jj_consume_token(SEMICOLON);
                   n12 = JTBToolkit.makeNodeToken(n13);
           n9.addNode(n12);
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
          n15 = Expression();
              n14.addNode(n15);
          break;
        default:
          ;
        }
           n9.addNode(n14);
           n4 = new NodeChoice(n9, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    n17 = jj_consume_token(SEMICOLON);
             n16 = JTBToolkit.makeNodeToken(n17);
    switch (jj_nt.kind) {
    case NUMBER:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case ALIGNOF:
    case SIZEOF:
    case GENERIC:
    case IDENTIFIER:
    case INC:
    case DEC:
    case RBL:
    case STAR:
    case PLUS:
    case MINUS:
    case EXCL:
    case AMP:
    case TILDE:
      n19 = Expression();
        n18.addNode(n19);
      break;
    default:
      ;
    }
    n21 = jj_consume_token(RBR);
             n20 = JTBToolkit.makeNodeToken(n21);
    n22 = Statement();
     {if (true) return new ForStatement(n0,n2,n4,n16,n18,n20,n22);}
    throw new Error("Missing return statement in function");
  }

  final public JumpStatement JumpStatement() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeSequence n13;
   NodeToken n14;
   Token n15;
   NodeToken n16;
   Token n17;
   ReturnStatement n18;
    switch (jj_nt.kind) {
    case GOTO:
           n1 = new NodeSequence(3);
      n3 = jj_consume_token(GOTO);
                     n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
      n5 = jj_consume_token(IDENTIFIER);
                           n4 = JTBToolkit.makeNodeToken(n5);
           n1.addNode(n4);
      n7 = jj_consume_token(SEMICOLON);
                  n6 = JTBToolkit.makeNodeToken(n7);
           n1.addNode(n6);
           n0 = new NodeChoice(n1, 0);
      break;
    case CONTINUE:
           n8 = new NodeSequence(2);
      n10 = jj_consume_token(CONTINUE);
                          n9 = JTBToolkit.makeNodeToken(n10);
           n8.addNode(n9);
      n12 = jj_consume_token(SEMICOLON);
                   n11 = JTBToolkit.makeNodeToken(n12);
           n8.addNode(n11);
           n0 = new NodeChoice(n8, 1);
      break;
    case BREAK:
           n13 = new NodeSequence(2);
      n15 = jj_consume_token(BREAK);
                       n14 = JTBToolkit.makeNodeToken(n15);
           n13.addNode(n14);
      n17 = jj_consume_token(SEMICOLON);
                   n16 = JTBToolkit.makeNodeToken(n17);
           n13.addNode(n16);
           n0 = new NodeChoice(n13, 2);
      break;
    case RETURN:
      n18 = ReturnStatement();
           n0 = new NodeChoice(n18, 3);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new JumpStatement(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ReturnStatement ReturnStatement() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   Expression n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(RETURN);
                 n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case NUMBER:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case ALIGNOF:
    case SIZEOF:
    case GENERIC:
    case IDENTIFIER:
    case INC:
    case DEC:
    case RBL:
    case STAR:
    case PLUS:
    case MINUS:
    case EXCL:
    case AMP:
    case TILDE:
      n3 = Expression();
        n2.addNode(n3);
      break;
    default:
      ;
    }
    n5 = jj_consume_token(SEMICOLON);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new ReturnStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  final public TranslationUnit TranslationUnit() throws ParseException {
   NodeList n0 = new NodeList();
   ExternalDeclaration n1;
      startScope();
    label_18:
    while (true) {
      n1 = ExternalDeclaration();
        n0.addNode(n1);
      if (jj_2_44(1)) {
        ;
      } else {
        break label_18;
      }
    }
     n0.nodes.trimToSize();
      endScope();
     {if (true) return new TranslationUnit(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ExternalDeclaration ExternalDeclaration() throws ParseException {
   NodeChoice n0;
   Declaration n1;
   FunctionDefinition n2;
    if (jj_2_45(2147483647)) {
      n1 = Declaration();
           n0 = new NodeChoice(n1, 0);
    } else if (jj_2_46(1)) {
      n2 = FunctionDefinition();
           n0 = new NodeChoice(n2, 1);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new ExternalDeclaration(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FunctionDefinition FunctionDefinition() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   DeclarationSpecifiers n1;
   Declarator n2;
   NodeOptional n3 = new NodeOptional();
   DeclarationList n4;
   CompoundStatement n5;
    if (jj_2_47(2147483647)) {
      n1 = DeclarationSpecifiers();
         lastType = null;
        n0.addNode(n1);
    } else {
      ;
    }
    n2 = Declarator();
    if (jj_2_48(1)) {
      n4 = DeclarationList();
        n3.addNode(n4);
    } else {
      ;
    }
    n5 = CompoundStatement();
     {if (true) return new FunctionDefinition(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  final public DeclarationList DeclarationList() throws ParseException {
   NodeList n0 = new NodeList();
   Declaration n1;
    label_19:
    while (true) {
      n1 = Declaration();
        n0.addNode(n1);
      if (jj_2_49(2147483647)) {
        ;
      } else {
        break label_19;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new DeclarationList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AttributeSpecifierList AttributeSpecifierList() throws ParseException {
   NodeList n0 = new NodeList();
   AttributeSpecifier n1;
    label_20:
    while (true) {
      n1 = AttributeSpecifier();
        n0.addNode(n1);
      switch (jj_nt.kind) {
      case ATTRIBUTE:
      case NONNULL:
      case ASM:
        ;
        break;
      default:
        break label_20;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new AttributeSpecifierList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public AttributeSpecifier AttributeSpecifier() throws ParseException {
   NodeChoice n0;
   NodeSequence n1;
   NodeChoice n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   AttributeList n11;
   NodeToken n12;
   Token n13;
   NodeToken n14;
   Token n15;
   Asm n16;
    switch (jj_nt.kind) {
    case ATTRIBUTE:
    case NONNULL:
        n1 = new NodeSequence(6);
      switch (jj_nt.kind) {
      case ATTRIBUTE:
        n4 = jj_consume_token(ATTRIBUTE);
                             n3 = JTBToolkit.makeNodeToken(n4);
              n2 = new NodeChoice(n3, 0);
        break;
      case NONNULL:
        n6 = jj_consume_token(NONNULL);
                           n5 = JTBToolkit.makeNodeToken(n6);
              n2 = new NodeChoice(n5, 1);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
        n1.addNode(n2);
      n8 = jj_consume_token(RBL);
               n7 = JTBToolkit.makeNodeToken(n8);
        n1.addNode(n7);
      n10 = jj_consume_token(RBL);
                n9 = JTBToolkit.makeNodeToken(n10);
        n1.addNode(n9);
      n11 = AttributeList();
        n1.addNode(n11);
      n13 = jj_consume_token(RBR);
                n12 = JTBToolkit.makeNodeToken(n13);
        n1.addNode(n12);
      n15 = jj_consume_token(RBR);
                n14 = JTBToolkit.makeNodeToken(n15);
        n1.addNode(n14);
        n0 = new NodeChoice(n1, 0);
      break;
    case ASM:
      n16 = Asm();
        n0 = new NodeChoice(n16, 1);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new AttributeSpecifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Asm Asm() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   StringLiteral n4;
   NodeToken n5;
   Token n6;
    n1 = jj_consume_token(ASM);
              n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = StringLiteral();
    n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new Asm(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
  }

  final public AttributeList AttributeList() throws ParseException {
   NodeOptional n0 = new NodeOptional();
   Attribute n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeOptional n6;
   Attribute n7;
    switch (jj_nt.kind) {
    case ALIGNOF:
    case AUTO:
    case BREAK:
    case CASE:
    case CHAR:
    case CONST:
    case CONTINUE:
    case DFAULT:
    case DO:
    case DOUBLE:
    case ELSE:
    case ENUM:
    case EXTERN:
    case FLOAT:
    case FOR:
    case GOTO:
    case IF:
    case INLINE:
    case INT:
    case LONG:
    case REGISTER:
    case RESTRICT:
    case RETURN:
    case SHORT:
    case SIGNED:
    case SIZEOF:
    case STATIC:
    case STRUCT:
    case SWITCH:
    case TYPEDEF:
    case UNION:
    case UNSIGNED:
    case VOID:
    case VOLATILE:
    case WHILE:
    case ALIGNAS:
    case ATOMIC:
    case BOOL:
    case COMPLEX:
    case GENERIC:
    case IMAGINARY:
    case NORETURN:
    case STATICASSERT:
    case THREADLOCAL:
    case IDENTIFIER:
      n1 = Attribute();
        n0.addNode(n1);
      break;
    default:
      ;
    }
    label_21:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        break label_21;
      }
        n6 = new NodeOptional();
        n3 = new NodeSequence(2);
      n5 = jj_consume_token(COMMA);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      switch (jj_nt.kind) {
      case ALIGNOF:
      case AUTO:
      case BREAK:
      case CASE:
      case CHAR:
      case CONST:
      case CONTINUE:
      case DFAULT:
      case DO:
      case DOUBLE:
      case ELSE:
      case ENUM:
      case EXTERN:
      case FLOAT:
      case FOR:
      case GOTO:
      case IF:
      case INLINE:
      case INT:
      case LONG:
      case REGISTER:
      case RESTRICT:
      case RETURN:
      case SHORT:
      case SIGNED:
      case SIZEOF:
      case STATIC:
      case STRUCT:
      case SWITCH:
      case TYPEDEF:
      case UNION:
      case UNSIGNED:
      case VOID:
      case VOLATILE:
      case WHILE:
      case ALIGNAS:
      case ATOMIC:
      case BOOL:
      case COMPLEX:
      case GENERIC:
      case IMAGINARY:
      case NORETURN:
      case STATICASSERT:
      case THREADLOCAL:
      case IDENTIFIER:
        n7 = Attribute();
           n6.addNode(n7);
        break;
      default:
        ;
      }
        n3.addNode(n6);
        n2.addNode(n3);
    }
     n2.nodes.trimToSize();
     {if (true) return new AttributeList(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  final public Attribute Attribute() throws ParseException {
   Word n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Expression n5;
   NodeToken n6;
   Token n7;
    n0 = Word();
    switch (jj_nt.kind) {
    case RBL:
        n2 = new NodeSequence(3);
      n4 = jj_consume_token(RBL);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Expression();
        n2.addNode(n5);
      n7 = jj_consume_token(RBR);
               n6 = JTBToolkit.makeNodeToken(n7);
        n2.addNode(n6);
        n1.addNode(n2);
      break;
    default:
      ;
    }
     {if (true) return new Attribute(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  final public Word Word() throws ParseException {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;
   NodeToken n25;
   Token n26;
   NodeToken n27;
   Token n28;
   NodeToken n29;
   Token n30;
   NodeToken n31;
   Token n32;
   NodeToken n33;
   Token n34;
   NodeToken n35;
   Token n36;
   NodeToken n37;
   Token n38;
   NodeToken n39;
   Token n40;
   NodeToken n41;
   Token n42;
   NodeToken n43;
   Token n44;
   NodeToken n45;
   Token n46;
   NodeToken n47;
   Token n48;
   NodeToken n49;
   Token n50;
   NodeToken n51;
   Token n52;
   NodeToken n53;
   Token n54;
   NodeToken n55;
   Token n56;
   NodeToken n57;
   Token n58;
   NodeToken n59;
   Token n60;
   NodeToken n61;
   Token n62;
   NodeToken n63;
   Token n64;
   NodeToken n65;
   Token n66;
   NodeToken n67;
   Token n68;
   NodeToken n69;
   Token n70;
   NodeToken n71;
   Token n72;
   NodeToken n73;
   Token n74;
   NodeToken n75;
   Token n76;
   NodeToken n77;
   Token n78;
   NodeToken n79;
   Token n80;
   NodeToken n81;
   Token n82;
   NodeToken n83;
   Token n84;
   NodeToken n85;
   Token n86;
   NodeToken n87;
   Token n88;
   NodeToken n89;
   Token n90;
    switch (jj_nt.kind) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
                        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
      break;
    case ALIGNOF:
      n4 = jj_consume_token(ALIGNOF);
                     n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
      break;
    case AUTO:
      n6 = jj_consume_token(AUTO);
                  n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
      break;
    case BREAK:
      n8 = jj_consume_token(BREAK);
                   n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
      break;
    case CASE:
      n10 = jj_consume_token(CASE);
                   n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
      break;
    case CHAR:
      n12 = jj_consume_token(CHAR);
                   n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
      break;
    case CONST:
      n14 = jj_consume_token(CONST);
                    n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
      break;
    case CONTINUE:
      n16 = jj_consume_token(CONTINUE);
                       n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
      break;
    case DFAULT:
      n18 = jj_consume_token(DFAULT);
                     n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
      break;
    case DO:
      n20 = jj_consume_token(DO);
                 n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9);
      break;
    case DOUBLE:
      n22 = jj_consume_token(DOUBLE);
                     n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10);
      break;
    case ELSE:
      n24 = jj_consume_token(ELSE);
                   n23 = JTBToolkit.makeNodeToken(n24);
        n0 = new NodeChoice(n23, 11);
      break;
    case ENUM:
      n26 = jj_consume_token(ENUM);
                   n25 = JTBToolkit.makeNodeToken(n26);
        n0 = new NodeChoice(n25, 12);
      break;
    case EXTERN:
      n28 = jj_consume_token(EXTERN);
                     n27 = JTBToolkit.makeNodeToken(n28);
        n0 = new NodeChoice(n27, 13);
      break;
    case FLOAT:
      n30 = jj_consume_token(FLOAT);
                    n29 = JTBToolkit.makeNodeToken(n30);
        n0 = new NodeChoice(n29, 14);
      break;
    case FOR:
      n32 = jj_consume_token(FOR);
                  n31 = JTBToolkit.makeNodeToken(n32);
        n0 = new NodeChoice(n31, 15);
      break;
    case GOTO:
      n34 = jj_consume_token(GOTO);
                   n33 = JTBToolkit.makeNodeToken(n34);
        n0 = new NodeChoice(n33, 16);
      break;
    case IF:
      n36 = jj_consume_token(IF);
                 n35 = JTBToolkit.makeNodeToken(n36);
        n0 = new NodeChoice(n35, 17);
      break;
    case INLINE:
      n38 = jj_consume_token(INLINE);
                     n37 = JTBToolkit.makeNodeToken(n38);
        n0 = new NodeChoice(n37, 18);
      break;
    case INT:
      n40 = jj_consume_token(INT);
                  n39 = JTBToolkit.makeNodeToken(n40);
        n0 = new NodeChoice(n39, 19);
      break;
    case LONG:
      n42 = jj_consume_token(LONG);
                   n41 = JTBToolkit.makeNodeToken(n42);
        n0 = new NodeChoice(n41, 20);
      break;
    case REGISTER:
      n44 = jj_consume_token(REGISTER);
                       n43 = JTBToolkit.makeNodeToken(n44);
        n0 = new NodeChoice(n43, 21);
      break;
    case RESTRICT:
      n46 = jj_consume_token(RESTRICT);
                       n45 = JTBToolkit.makeNodeToken(n46);
        n0 = new NodeChoice(n45, 22);
      break;
    case RETURN:
      n48 = jj_consume_token(RETURN);
                     n47 = JTBToolkit.makeNodeToken(n48);
        n0 = new NodeChoice(n47, 23);
      break;
    case SHORT:
      n50 = jj_consume_token(SHORT);
                    n49 = JTBToolkit.makeNodeToken(n50);
        n0 = new NodeChoice(n49, 24);
      break;
    case SIGNED:
      n52 = jj_consume_token(SIGNED);
                     n51 = JTBToolkit.makeNodeToken(n52);
        n0 = new NodeChoice(n51, 25);
      break;
    case SIZEOF:
      n54 = jj_consume_token(SIZEOF);
                     n53 = JTBToolkit.makeNodeToken(n54);
        n0 = new NodeChoice(n53, 26);
      break;
    case STATIC:
      n56 = jj_consume_token(STATIC);
                     n55 = JTBToolkit.makeNodeToken(n56);
        n0 = new NodeChoice(n55, 27);
      break;
    case STRUCT:
      n58 = jj_consume_token(STRUCT);
                     n57 = JTBToolkit.makeNodeToken(n58);
        n0 = new NodeChoice(n57, 28);
      break;
    case SWITCH:
      n60 = jj_consume_token(SWITCH);
                     n59 = JTBToolkit.makeNodeToken(n60);
        n0 = new NodeChoice(n59, 29);
      break;
    case TYPEDEF:
      n62 = jj_consume_token(TYPEDEF);
                      n61 = JTBToolkit.makeNodeToken(n62);
        n0 = new NodeChoice(n61, 30);
      break;
    case UNION:
      n64 = jj_consume_token(UNION);
                    n63 = JTBToolkit.makeNodeToken(n64);
        n0 = new NodeChoice(n63, 31);
      break;
    case UNSIGNED:
      n66 = jj_consume_token(UNSIGNED);
                       n65 = JTBToolkit.makeNodeToken(n66);
        n0 = new NodeChoice(n65, 32);
      break;
    case VOID:
      n68 = jj_consume_token(VOID);
                   n67 = JTBToolkit.makeNodeToken(n68);
        n0 = new NodeChoice(n67, 33);
      break;
    case VOLATILE:
      n70 = jj_consume_token(VOLATILE);
                       n69 = JTBToolkit.makeNodeToken(n70);
        n0 = new NodeChoice(n69, 34);
      break;
    case WHILE:
      n72 = jj_consume_token(WHILE);
                    n71 = JTBToolkit.makeNodeToken(n72);
        n0 = new NodeChoice(n71, 35);
      break;
    case ALIGNAS:
      n74 = jj_consume_token(ALIGNAS);
                      n73 = JTBToolkit.makeNodeToken(n74);
        n0 = new NodeChoice(n73, 36);
      break;
    case ATOMIC:
      n76 = jj_consume_token(ATOMIC);
                     n75 = JTBToolkit.makeNodeToken(n76);
        n0 = new NodeChoice(n75, 37);
      break;
    case BOOL:
      n78 = jj_consume_token(BOOL);
                   n77 = JTBToolkit.makeNodeToken(n78);
        n0 = new NodeChoice(n77, 38);
      break;
    case COMPLEX:
      n80 = jj_consume_token(COMPLEX);
                      n79 = JTBToolkit.makeNodeToken(n80);
        n0 = new NodeChoice(n79, 39);
      break;
    case GENERIC:
      n82 = jj_consume_token(GENERIC);
                      n81 = JTBToolkit.makeNodeToken(n82);
        n0 = new NodeChoice(n81, 40);
      break;
    case IMAGINARY:
      n84 = jj_consume_token(IMAGINARY);
                        n83 = JTBToolkit.makeNodeToken(n84);
        n0 = new NodeChoice(n83, 41);
      break;
    case NORETURN:
      n86 = jj_consume_token(NORETURN);
                       n85 = JTBToolkit.makeNodeToken(n86);
        n0 = new NodeChoice(n85, 42);
      break;
    case STATICASSERT:
      n88 = jj_consume_token(STATICASSERT);
                           n87 = JTBToolkit.makeNodeToken(n88);
        n0 = new NodeChoice(n87, 43);
      break;
    case THREADLOCAL:
      n90 = jj_consume_token(THREADLOCAL);
                          n89 = JTBToolkit.makeNodeToken(n90);
        n0 = new NodeChoice(n89, 44);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Word(n0);}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_3R_362() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_143()) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_43()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_27()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_scan_token(EXTENSION)) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_356() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_362()) {
    jj_scanpos = xsp;
    if (jj_3R_363()) return true;
    }
    if (jj_3R_347()) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_scan_token(COMPLEX)) return true;
    return false;
  }

  private boolean jj_3R_157() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_scan_token(THREADLOCAL)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_scan_token(BOOL)) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_3R_355()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_356()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_scan_token(STATICASSERT)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(UNSIGNED)) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_scan_token(NORETURN)) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(SIGNED)) return true;
    return false;
  }

  private boolean jj_3R_329() {
    if (jj_scan_token(IMAGINARY)) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_328() {
    if (jj_scan_token(GENERIC)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(ELLIPSIS)) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_scan_token(COMPLEX)) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_3R_102()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_255()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_scan_token(BOOL)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    }
    return false;
  }

  private boolean jj_3R_367() {
    if (jj_scan_token(MOD)) return true;
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_scan_token(ATOMIC)) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3R_366() {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_scan_token(ALIGNAS)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_365() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_323() {
    if (jj_scan_token(WHILE)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_322() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_321() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = (lastType == null || !lastType.equals(getToken(1).image)) && isType(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_97()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_3R_133()) return true;
    return false;
  }

  private boolean jj_3R_361() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_365()) {
    jj_scanpos = xsp;
    if (jj_3R_366()) {
    jj_scanpos = xsp;
    if (jj_3R_367()) return true;
    }
    }
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_320() {
    if (jj_scan_token(UNSIGNED)) return true;
    return false;
  }

  private boolean jj_3R_49() {
    Token xsp;
    if (jj_3_40()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_40()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    Token xsp;
    if (jj_3R_101()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_101()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_355() {
    if (jj_3R_25()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_361()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_318() {
    if (jj_scan_token(TYPEDEF)) return true;
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_scan_token(SWITCH)) return true;
    return false;
  }

  private boolean jj_3R_316() {
    if (jj_scan_token(STRUCT)) return true;
    return false;
  }

  private boolean jj_3R_315() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_314() {
    if (jj_scan_token(SIZEOF)) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_313() {
    if (jj_scan_token(SIGNED)) return true;
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(STAR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_105()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_311() {
    if (jj_scan_token(RETURN)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_22()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(CBL)) return true;
    return false;
  }

  private boolean jj_3R_310() {
    if (jj_scan_token(RESTRICT)) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_scan_token(REGISTER)) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_22()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(INLINE)) return true;
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(TYPEDEF)) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(IF)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    }
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_scan_token(REGISTER)) return true;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_3R_256()) return true;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(GOTO)) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_scan_token(AUTO)) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(DFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(THREADLOCAL)) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_236()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(EXTERN)) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_scan_token(EXTERN)) return true;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(ENUM)) return true;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(ELSE)) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_scan_token(EXCL)) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_42()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_132() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_254() {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_scan_token(DO)) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_235() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_254()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_scan_token(DFAULT)) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_scan_token(CONTINUE)) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_294() {
    if (jj_scan_token(CONST)) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_scan_token(AMP)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_155()) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_scan_token(CASE)) return true;
    return false;
  }

  private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) jj_scanpos = xsp;
    if (jj_scan_token(STAR)) return true;
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_scan_token(BREAK)) return true;
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_scan_token(AUTO)) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_scan_token(ALIGNOF)) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(STATIC)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_3R_44()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_257()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_279() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_288()) {
    jj_scanpos = xsp;
    if (jj_3R_289()) {
    jj_scanpos = xsp;
    if (jj_3R_290()) {
    jj_scanpos = xsp;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_3R_292()) {
    jj_scanpos = xsp;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) {
    jj_scanpos = xsp;
    if (jj_3R_295()) {
    jj_scanpos = xsp;
    if (jj_3R_296()) {
    jj_scanpos = xsp;
    if (jj_3R_297()) {
    jj_scanpos = xsp;
    if (jj_3R_298()) {
    jj_scanpos = xsp;
    if (jj_3R_299()) {
    jj_scanpos = xsp;
    if (jj_3R_300()) {
    jj_scanpos = xsp;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) {
    jj_scanpos = xsp;
    if (jj_3R_303()) {
    jj_scanpos = xsp;
    if (jj_3R_304()) {
    jj_scanpos = xsp;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) {
    jj_scanpos = xsp;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) {
    jj_scanpos = xsp;
    if (jj_3R_311()) {
    jj_scanpos = xsp;
    if (jj_3R_312()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) {
    jj_scanpos = xsp;
    if (jj_3R_314()) {
    jj_scanpos = xsp;
    if (jj_3R_315()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) {
    jj_scanpos = xsp;
    if (jj_3R_317()) {
    jj_scanpos = xsp;
    if (jj_3R_318()) {
    jj_scanpos = xsp;
    if (jj_3R_319()) {
    jj_scanpos = xsp;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) {
    jj_scanpos = xsp;
    if (jj_3R_322()) {
    jj_scanpos = xsp;
    if (jj_3R_323()) {
    jj_scanpos = xsp;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) {
    jj_scanpos = xsp;
    if (jj_3R_328()) {
    jj_scanpos = xsp;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) {
    jj_scanpos = xsp;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(STATIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_253()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(ALIGNOF)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_22()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(SBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) return true;
    }
    }
    }
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_238()) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_3R_238()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_239()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_151() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_3R_163()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_22()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_162()) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_161()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_44()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_3R_159()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(SIZEOF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_3R_130()) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(DEC)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_3R_135()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_139()) jj_scanpos = xsp;
    if (jj_3R_140()) return true;
    xsp = jj_scanpos;
    if (jj_3R_141()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_151()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(INC)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_134()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_133()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_137()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(STATICASSERT)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_209()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_217()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_132()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_136()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_221()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_3R_279()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_280()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_103()) jj_scanpos = xsp;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_scan_token(SBL)) return true;
    if (jj_3R_209()) return true;
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_3R_56()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_57()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_335() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_339()) {
    jj_scanpos = xsp;
    if (jj_3R_340()) return true;
    }
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_3R_266()) return true;
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(DEC)) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_3R_146()) return true;
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_3R_145()) return true;
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_267()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_scan_token(INC)) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_3R_266()) return true;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_scan_token(ARROW)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(ALIGNAS)) return true;
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    jj_lookingAhead = true;
    jj_semLA = isType(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) return true;
    }
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_228() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_251()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_252()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_3R_216()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_335()) return true;
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_3R_215()) return true;
    return false;
  }

  private boolean jj_3R_276() {
    Token xsp;
    if (jj_3R_285()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_285()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(NORETURN)) return true;
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_28()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_164()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_165()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(INLINE)) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(ASM)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_217()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_3R_276()) return true;
    if (jj_scan_token(ASSIGNMENT)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) return true;
    }
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_scan_token(SBL)) return true;
    if (jj_3R_221()) return true;
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) return true;
    }
    return false;
  }

  private boolean jj_3R_129() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_3R_229()) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_3R_128()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_129()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_37() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(ATOMIC)) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_3R_265()) return true;
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_3R_166()) return true;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(RESTRICT)) return true;
    return false;
  }

  private boolean jj_3R_224() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_249()) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_37()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_scan_token(NONNULL)) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(CONST)) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_scan_token(ATTRIBUTE)) return true;
    return false;
  }

  private boolean jj_3R_133() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_22()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_224()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_225()) jj_scanpos = xsp;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) return true;
    }
    if (jj_scan_token(RBL)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_228()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    }
    return false;
  }

  private boolean jj_3R_140() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) return true;
    }
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_3R_56()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_247()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_224()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_277()) jj_scanpos = xsp;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_250() {
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(ATOMIC)) return true;
    if (jj_scan_token(RBL)) return true;
    jj_lookingAhead = true;
    jj_semLA = isType(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_250()) return true;
    if (jj_3R_145()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(OR_EQ)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(XOR_EQ)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(AND_EQ)) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(RSH_EQ)) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_3R_140()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(LSH_EQ)) return true;
    return false;
  }

  private boolean jj_3R_216() {
    Token xsp;
    if (jj_3R_240()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_240()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(SUB_EQ)) return true;
    return false;
  }

  private boolean jj_3_49() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(PLUS_EQ)) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(MOD_EQ)) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(DIV_EQ)) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_100()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_148()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(MULT_EQ)) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    return false;
  }

  private boolean jj_3R_55() {
    Token xsp;
    if (jj_3R_125()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_125()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_scan_token(DFAULT)) return true;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3_48() {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3_47() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_275() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_284()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_286() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3_1()) return true;
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) jj_scanpos = xsp;
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(STATIC)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_26()) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_3R_166()) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_286()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_273() {
    if (jj_scan_token(STATIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_283()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3_46() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_3R_286()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_287()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_3R_26()) return true;
    if (jj_3R_27()) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) return true;
    }
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_scan_token(SBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_273()) {
    jj_scanpos = xsp;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) return true;
    }
    }
    }
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_36()) jj_scanpos = xsp;
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_37()) return true;
    xsp = jj_scanpos;
    if (jj_3R_38()) jj_scanpos = xsp;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3_46()) return true;
    }
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_34()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(ENUM)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_scan_token(GENERIC)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_56()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_278()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_scan_token(QEM)) return true;
    if (jj_3R_221()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_166()) return true;
    return false;
  }

  private boolean jj_3R_248() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) return true;
    }
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_272() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_262() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_272()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_222()) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_3R_244()) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_3R_218()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_219()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_221()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(STATIC)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_3R_217()) return true;
    return false;
  }

  private boolean jj_3R_271() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_3R_220()) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_scan_token(RETURN)) return true;
    return false;
  }

  private boolean jj_3R_364() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_scan_token(STATIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_271()) jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_scan_token(LOR)) return true;
    if (jj_3R_218()) return true;
    return false;
  }

  private boolean jj_3R_359() {
    if (jj_3R_44()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_364()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_353() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_359()) {
    jj_scanpos = xsp;
    if (jj_3R_360()) return true;
    }
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_3R_242()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_243()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_scan_token(SBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) return true;
    }
    }
    }
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(BREAK)) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(CONTINUE)) return true;
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_scan_token(LAND)) return true;
    if (jj_3R_242()) return true;
    return false;
  }

  private boolean jj_3R_217() {
    Token xsp;
    if (jj_3R_241()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_241()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_3R_258()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_259()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_scan_token(GOTO)) return true;
    return false;
  }

  private boolean jj_3R_354() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_353()) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_46()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_346() {
    if (jj_3R_353()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_354()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_163() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_153() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_248()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_scan_token(PIPE)) return true;
    if (jj_3R_258()) return true;
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_3R_269()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_270()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_220() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_3R_133()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_scan_token(CARE)) return true;
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    }
    return false;
  }

  private boolean jj_3R_269() {
    if (jj_3R_281()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_43() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_146()) return true;
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_3R_346()) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_scan_token(AMP)) return true;
    if (jj_3R_281()) return true;
    return false;
  }

  private boolean jj_3R_281() {
    if (jj_3R_333()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_334()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_341()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) return true;
    }
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_345() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_344() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_107() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_152()) jj_scanpos = xsp;
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_338() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_344()) {
    jj_scanpos = xsp;
    if (jj_3R_345()) return true;
    }
    if (jj_3R_333()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    }
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_3R_337()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_338()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    Token xsp;
    if (jj_3_17()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_17()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(DO)) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_scan_token(STRUCT)) return true;
    return false;
  }

  private boolean jj_3R_352() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_351() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_350() {
    if (jj_scan_token(GREATER)) return true;
    return false;
  }

  private boolean jj_3R_200() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) return true;
    }
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_scan_token(LESS)) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_scan_token(WHILE)) return true;
    return false;
  }

  private boolean jj_3R_343() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_349()) {
    jj_scanpos = xsp;
    if (jj_3R_350()) {
    jj_scanpos = xsp;
    if (jj_3R_351()) {
    jj_scanpos = xsp;
    if (jj_3R_352()) return true;
    }
    }
    }
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_3R_342()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_343()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_268()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(SWITCH)) return true;
    return false;
  }

  private boolean jj_3_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) jj_scanpos = xsp;
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_358() {
    if (jj_scan_token(RSH)) return true;
    return false;
  }

  private boolean jj_3R_204() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_357() {
    if (jj_scan_token(LSH)) return true;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_3R_200()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) return true;
    }
    return false;
  }

  private boolean jj_3R_348() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_357()) {
    jj_scanpos = xsp;
    if (jj_3R_358()) return true;
    }
    if (jj_3R_342()) return true;
    return false;
  }

  private boolean jj_3_42() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_3R_347()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_348()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_3R_28()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) return true;
    }
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_scan_token(IF)) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_145()) return true;
    return false;
  }

  private boolean jj_3R_363() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_144()) return true;
    return false;
  }

  /** User defined Token Manager. */
  public TokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;


  /** Constructor with user supplied Token Manager. */
  public CParser(TokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  /** Reinitialise. */
  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      return token;
    }
    jj_nt = token;
    token = oldToken;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      NodeToken n = new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
        n.beginOffset = t.beginOffset;
        n.endOffset = t.endOffset;
        return n;
   }
}
